{"0": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com . You can find the source code for Minima at GitHub: jekyll / minima . You can find the source code for Jekyll at GitHub: jekyll / jekyll . ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"1": {
    "doc": "Authorization",
    "title": "How Cedar authorization works",
    "content": "Each time a user of your application wants to perform an action on a protected resource, the application needs to invoke the Cedar authorization engine (or authorizer, for short) to check if this request is allowed. The authorizer considers the request against the application’s store of policies in order to make a decision, Allow or Deny. This topic discusses how the Cedar authorizer decides the answer to a particular request. ",
    "url": "/authorization.html#how-cedar-authorization-works",
    
    "relUrl": "/authorization.html#how-cedar-authorization-works"
  },"2": {
    "doc": "Authorization",
    "title": "Request creation",
    "content": "A Cedar authorization request asks the question “Can this principal take this action on this resource in this context?”. More formally, an authorization request has four parts, abbreviated PARC: . | P is the principal, | A is the action, | R is the resource, and | C is the request context. | . P, A, and R are entity references, while C is a record. Conceptually, you should imagine that the authorizer is able to consider all of your application’s policies and entity data while evaluating a request. As a practical matter, making all policies and entity data available might be too difficult or too expensive. In that case, your application needs to determine which policies and entity data are relevant to properly handling the request. ",
    "url": "/authorization.html#request-creation",
    
    "relUrl": "/authorization.html#request-creation"
  },"3": {
    "doc": "Authorization",
    "title": "Request authorization",
    "content": "Given an authorization request, Cedar’s authorizer returns Allow if the request is granted or Deny if it is rejected, along with some diagnostics. How does it make this decision? . Algorithm . First, the authorizer evaluates each of the policies to determine if the policy satisfies the request. More details about evaluation follow, but in summary, know that the evaluator can return: . | true, when the policy satisfies the request; | false, when the policy does not satisfy the request; or | error, when there is an error when evaluating the policy on the request data. | . After evaluating each policy, the authorizer combines the results to make an authorization decision. It makes its decision by applying the following rules: . | If any forbid policy evaluates to true, then the final result is Deny. | Else, if any permit policy evaluates to true, then the final result is Allow. | Otherwise (i.e., no policy is satisfied), the final result is Deny. | . The authorizer returns an authorization response, which includes its decision along with some diagnostics. These diagnostics include the determining policies and any error conditions. If the decision is Allow, the determining policies are the permit policies that satisfy the request (rule 2). Otherwise, the determining policies are the forbid policies, if any, that satisfy the request (rule 1). If the decision is Deny because no policies were satisfied (rule 3), then the list of determining policies is empty. Whatever the final result, if the evaluation of any policies resulted in error, then the IDs of the erroneous policies are included in the diagnostics, too, along with the particulars of the errors. Discussion . Cedar’s authorization algorithm has three useful properties: . | default deny: no request is authorized (decision Allow) unless there is a specific permit policy that grants it; by default, the decision is Deny. | forbid overrides permit: even if a permit policy is satisfied, any satisfied forbid policy overrides it, producing a Deny decision. | skip on error: if a policy’s evaluation returns error, the policy does not factor into the authorization response; it is skipped. | . Why was Cedar’s authorization algorithm designed to satisfy these properties? The first two properties make Cedar policies easier to understand. Since permit policies are the only way access is granted, readers just have to understand what each policy says, not what it doesn’t. Because forbid policies always deny access, readers can understand them independently of any permit policies created now or in the future; forbid policies effectively define permission “guardrails” that permit policies cannot cross. The reasoning for the skip-on-error property is more involved. An alternative authorization algorithm we considered would be to Deny a request when any policy evaluation exhibits an error. While this might sound good at first, deny-on-error raises concerns of safety. An application that was working fine with 100 policies might suddenly start denying all requests if the 101st policy has an error. Skip-on-error avoids this dramatic failure mode, and is more flexible: applications can always choose to look at the authorization response’s diagnostics and take a different decision if an evaluated policy produces errors. For more information, see this blog post written by one of the Cedar designers. ",
    "url": "/authorization.html#request-authorization",
    
    "relUrl": "/authorization.html#request-authorization"
  },"4": {
    "doc": "Authorization",
    "title": "Policy evaluation",
    "content": "As just discussed, to reach its decision the Cedar authorizer’s algorithm evaluates a request PARC against each policy it is given. Evaluation returns whether or not the policy is satisfied by the request (true/false), or whether an error occurred during evaluation (error). How does evaluation work? . Expression evaluation . The key component of policy evaluation is expression evaluation. Each constraint in the policy scope is an expression. Each when clause also contains an expression, as does each unless clause. Evaluating a policy requires evaluating its constituent expressions. Example expressions include resource.tags.contains(\"private\"), action == Action::\"viewPhoto\", principal in Team::\"admin\", and resource in principal.account. As with a typical programming language, evaluating an expression simplifies, or “executes”, the expression until no further simplification is possible. The final result is either a Cedar value – like true, 1, User::\"Alice\", or \"blue\" – or it is an error. Evaluating an expression with no variables is straightforward. The expression 2+2 evaluates to 4. Expression Action::\"viewPhoto\" == Action::\"viewPhoto\" evaluates to true. Expression if false then \"blue\" else \"green\" evaluates to \"green\". See here for complete descriptions of the various operators you can use in Cedar expressions. What about expressions that have variables principal, action, resource, and context in them? To evaluate such expressions the Cedar authorizer first binds any variables that appear in the expressions to values of the appropriate type. Then theh authorizer evaluates the expressions with those values in place of the variables. For example, consider the expression action == Action::\"viewPhoto\". If the authorizer binds the action variable to the entity Action::\"viewPhoto\", then the result is true. That’s because replacing action with Action::\"viewPhoto\" gives expression Action::\"viewPhoto\" == Action::\"viewPhoto\" which is obviously true. As another example, consider the expression resource.tags.contains(\"Private\"). If the authorizer binds the resource variable to the entity Photo::\"vacation94.jpg\" we get Photo::\"vacation94.jpg\".tags.contains(\"Private\"). Evaluating further, the authorizer must look up Photo::\"vacation94.jpg\" in the provided entities data, and then extract its tags attribute. If that attribute contains a set with the string \"Private\" in it, the result is true; if it’s a set without \"Private\" the result is false. Otherwise tags is either not a valid attribute or contains a non-set, and Cedar generates an error. Policy satisfaction . Determining whether a policy satsifies a request is a straightforward use of expression evaluation. To explain it, let’s introduce some notation. For a policy c: . | Principal(c) is the constraint involving the principal in c’s policy scope. If there is no constraint on principal, then Principal(c) is true. | Action(c) is the constraint involving action in c’s policy scope. If there is no constraint on action, then Action(c) is true. | Resource(c) is the constraint involving resource in c’s policy scope. If there is no constraint on resource, then Resource(c) is true. | Conds(c) is the list of when and unless expressions in c. | . Here’s how the Cedar authorizer evaluates a policy c with respect to a PARC request. First, the authorizer tests whether c matches the request, as follows: . | Bind principal to P in expression Principal(c) and evaluate it | Bind action to A in expression Action(c) and evaluate it | Bind resource to R in expression Resource(c) and evaluate it | . If all three steps evaluate to true, then c matches the request. Otherwise it does not. (Cedar’s design ensures that none of these three steps can possibly evaluate to error.) . If c matches the request, the authorizer evaluates the request’s conditions Conds(c) in order. The authorizer binds the principal, action, resource, and context variables to the PARC values when we do so. If all of the when conditions evaluate to true, and all of the unless conditions evaluate to false, then policy c satsifies the request, and the final evaluation result is true. If evaluating any condition expression yields error then policy evaluation halts at that point (any remaining conditions are skipped), and error is returned as the final result. Otherwise, false is returned. ",
    "url": "/authorization.html#policy-evaluation",
    
    "relUrl": "/authorization.html#policy-evaluation"
  },"5": {
    "doc": "Authorization",
    "title": "Detailed Example",
    "content": "To illustrate policy evaluation, consider whether a set of four policies authorizes the following request: “Can the user jane perform the action viewPhoto on the photo vacation.jpg?” Precisely, the request is: . | P = User::\"jane\" | A = Action::\"viewPhoto\" | R = Photo::\"vacation.jpg\" | C = {} (the empty record) | . Assume that the entities data includes the following details: . | Entity User::\"jane\" is a member of Group::\"kevinsFriends\" | Entity Photo::\"vacation.jpg\" has the following attributes: . | .owner is User::\"kevin\" | .tags is [\"Private\",\"Work\"] (i.e., a set containing the strings \"Private\" and \"Work\") | . | . The Cedar authorizer evaluates each of the four policies against this request. | P1 – Jane can perform any action on photo vacation.jpg. permit( principal == User::\"jane\", action, resource == Photo::\"vacation.jpg\" ); . This policy is satisfied. | Principal in P1 is principal == User::\"jane\", so after binding principal to User::\"jane\" (the P in the request), the expression evaluates to true. | Action in P1 is simply true since there is no action constraint. | Resource in P1 is resource == Photo::\"vacation.jpg\", so after binding resource to Photo::\"vacation.jpg\" (the R in the request), the expression evaluates to true. | Cond(c) is empty, so evaluates trivially to true. | . | P2 – A member of group kevinFriends can view any of Kevin’s photos when they are tagged Holiday . permit( principal in UserGroup::\"kevinFriends\", action == Action::\"viewPhoto\", resource ) when { resource.tags.contains(\"Holiday\") }; . This policy is not satisfied. While it matches the request, its condition evaluates to false. | Principal in P2 is principal in UserGroup::\"kevinFriends\", so after binding principal to User::\"jane\" (the P in the request), the expression evaluates to true because User::\"jane\" is a member of Group::\"kevinsFriends\" | Action in P2 is action == Action::\"viewPhoto\", so after binding action to Action::\"viewPhoto\" the expression evaluates to true | Resource in P2 is simply true since there is no resource constraint | Cond(c) in P2 is the list containing when expression resource.tags.contains(\"Holiday\"). After binding resource to Photo::\"vacation.jpg\" (the R in the request), the expression evaluates to false because the .tags attribute of Photo::\"vacation.jpg\" is [\"Private\",\"Work\"], i.e., it does not contain \"Holiday\". | . | P3 – Users are forbidden from viewing any photos tagged Private unless they are the owner of the photo. forbid( principal, action == Action::\"viewPhoto\", resource ) when { resource.tags.contains(\"Private\") } unless { principal == resource.owner }; . This policy is satisfied. | The policy matches the request: principal and resource are unconstrained, and Action(c) evaluates to true because A is Action::\"viewPhoto\"; | The policy’s when condition is true because the .tags attribute of Photo::\"vacation.jpg\" contains \"Private\"; and | The policy’s unless condition is false because the .owner attribute of Photo::\"vacation.jpg\" (which is User::\"kevin\") is not equal to P (which is User::\"jane\"). | . | P4 – Users can perform updateTags on a resource, like a Photo or Album, when they are the owner of the resource . permit( principal, action == Action::\"updateTags\", resource ) when { principal == resource.owner }; . This policy is not satisfied. | The policy fails to match the request because while principal and resource are unconstrained, Action(c) evaluates to false because binding action to A yields expression Action::\"viewPhoto\" == Action::\"updatePassword\". | . | . In sum: . | permit policy P1 evaluates to true | permit policy P2 evaluates to false | forbid policy P3 evaluates to true | permit policy P4 evaluates to false | . Combining these policy evaluation results, the Cedar authorizer returns a decision of Deny, where the determining policy is P3. This result follows from rule 1 of our authorization logic: “If any forbid policy evaluates to true, then the final result is Deny” (and the determining policies are the satisfied forbid policies). ",
    "url": "/authorization.html#detailed-example",
    
    "relUrl": "/authorization.html#detailed-example"
  },"6": {
    "doc": "Authorization",
    "title": "Authorization",
    "content": " ",
    "url": "/authorization.html",
    
    "relUrl": "/authorization.html"
  },"7": {
    "doc": "Document history",
    "title": "Document history for the Cedar Policy Language Guide",
    "content": "The following table describes major documentation updates for Cedar. | Change | Description | Date | . | 2.3 | Implements RFC 9 that disallows whitespace in identifiers | June 29, 2023 | . | 2.2 | Changes to Cedar API that don’t affect the policy language | May 30, 2023 | . | 2.1 | Changes to Cedar API that don’t affect the policy language | May 25, 2023 | . | 2.0 | Initial release of the Cedar Policy Language Guide | May 10, 2023 | . ",
    "url": "/doc-history.html#document-history-for-the-cedar-policy-language-guide",
    
    "relUrl": "/doc-history.html#document-history-for-the-cedar-policy-language-guide"
  },"8": {
    "doc": "Document history",
    "title": "Document history",
    "content": " ",
    "url": "/doc-history.html",
    
    "relUrl": "/doc-history.html"
  },"9": {
    "doc": "Table of contents",
    "title": "In this guide",
    "content": ". | What is the Cedar policy language? | Cedar terms and concepts | Cedar example scenario used in this guide | Cedar authorization | Cedar policy validation against schema | Cedar schema format | Cedar policy templates | Cedar syntax – elements of the policy language . | Basic policy construction | Entity | Cedar syntax – data types supported by the policy language | Cedar syntax – operators and functions | Cedar grammar – putting the elements together | . | Cedar security | Document history for the Cedar Policy Language Guide | . You can also view the Cedar language specification or download as a PDF . ",
    "url": "/#in-this-guide",
    
    "relUrl": "/#in-this-guide"
  },"10": {
    "doc": "Table of contents",
    "title": "Table of contents",
    "content": ". ",
    "url": "/",
    
    "relUrl": "/"
  },"11": {
    "doc": "Example scenario",
    "title": "Cedar example scenario used in this guide",
    "content": "Conventions used in this guide In this guide, entity type names are always spelled using PascalCase, with the first letter of each word capitalized. For example, UserGroup. Individual entity and attribute names are spelled using camelCase, with only the first letter of the second and following words capitalized. For example, janeFriends. The examples in this guide use the following hypothetical photo sharing application, called PhotoFlash. This application provides users with the ability to store, organize, and share their photos. Users can upload photos to their PhotoFlash account and organize them into albums. Albums can be nested in other albums and photos can belong to multiple albums. Users can also add custom metadata, such as the names of people visible, to each photo in the form of tags. Then, users can search for photos based on the attached metadata, such as searching for any photos that were taken after a certain date or at a certain geographic location. PhotoFlash users can share their photos and albums with other PhotoFlash users or user groups. In the previous illustration, a user named jane created groups to represent her family (janeFamily), friends (janeFriends), and coworkers (janeCoworkers). She can then populate those groups with other PhotoFlash users, and specify how members of those groups can access her photos and albums. User groups are as flexible as albums; they can be nested, and a user can belong to multiple groups. This guide includes examples that use simple entity identifiers, such as jane or bob for the name of an entity of type User. This approach makes the examples more readable. However, in a production system, it’s critical for security reasons that you use unique values that can’t be reused. We recommend that you use values like universally unique identifiers (UUIDs). For example, a user jane leaves the company. Later, you let someone else use the name jane. That new user gets access automatically to everything granted by policies that still reference User::\"jane\". Cedar can’t distinguish between the new user and the previous user. This warning applies to both principal and resource identifiers. Always use identifiers that are guaranteed unique and never reused to ensure that you don’t grant access unintentionally because of the presence of an old identifier in a policy. Where this guide does show a UUID for an entity, it also shows the entity’s display name as a comment to make the policies easier to understand. For example: . principal == User::\"a1b2c3d4-e5f6-a1b2-c3d4-EXAMPLE11111\", // alice . The photos have metadata, such as a created date timestamp, and each photo can optionally have user-defined tags attached, such as the tags private, work, and fun. Based on group membership, Jane can allow certain users to perform specific actions on her PhotoFlash resources. For example, the following policy allows members of the group janeFriends to view and comment on any photo in the album janeTrips. Because the in operator works transitively, it also applies to any photos in albums that are nested within the album janeTrips. Therefore, this example also allows access to the pictures in albums janeVacation and conference. // Jane's friends can view all photos in her janeTrips album permit( principal in Group::\"janeFriends\", action in [Action::\"view\", Action::\"comment\"], resource in Album::\"janeTrips\" ); . Any action that isn’t explicitly permitted is denied. You can also choose to always deny some actions as a matter of service-wide security or design constraints, even if a user explicitly tries to allow those actions. For example, the following policy ensures that no user other than the owner of the account that contains the resource can perform any action if that resource is tagged private. The following policy doesn’t specify any specific principal, action, or resource. The policy matches any request automatically and denies access if either the when or unless expressions evaluate to true for that request. // Only the owner can access any resource tagged \"private\" forbid( principal, action, resource ) when { resource.tags.contains(\"private\") } // assumes that resource has \"tags\" unless { resource in principal.account }; // assumes that principal has \"account\" . The order of the when and unless clauses matters in the case where one or more of them generate errors. Cedar evaluates the when and unless clauses in the order in which they appear in the policy. In the previous example, consider a scenario where the when and unless clauses generate separate errors. The order determines which error you actually see. If only one clause causes an error, the order can have an impact on the resulting evaluation, but not authorization, behavior. ",
    "url": "/scenario.html#cedar-example-scenario-used-in-this-guide",
    
    "relUrl": "/scenario.html#cedar-example-scenario-used-in-this-guide"
  },"12": {
    "doc": "Example scenario",
    "title": "Example scenario",
    "content": " ",
    "url": "/scenario.html",
    
    "relUrl": "/scenario.html"
  },"13": {
    "doc": "Schema format",
    "title": "Cedar schema format",
    "content": "Topics on this page . | Overview | Schema format | Namespace | entityTypes . | Entity type name | memberOfTypes | shape | Attribute specifications | Attribute types | . | actions . | Action name | memberOf | appliesTo | context | . | commonTypes . | Motivation | Structure | . | Example schema | . ",
    "url": "/schema.html#cedar-schema-format",
    
    "relUrl": "/schema.html#cedar-schema-format"
  },"14": {
    "doc": "Schema format",
    "title": "Overview",
    "content": "A schema is a declaration of the structure of the entity types that you want to support in your application and for which you want Cedar to provide authorization services. Cedar uses JSON to define a schema. It bears some resemblance to JSON Schema, but unique aspects of the design of Cedar, such as its use of entity types, require some differences. You can use a schema to define each of the following entities used by your application: . | Principals – The entities that represent the users of your application. In the schema for the example PhotoFlash application, the principals consist of the user and group entity types. You can define the properties of each principal, such as a name, age, address, or any other characteristic that is important to your application. | Resources – The entities that your principals can interact with. In the PhotoFlash application, resource entities could include the photo and the album resource types. These resource entities can also include the properties of each resource, such as a photo’s name, location where taken, resolution, codec type, and so on. | Actions – The operations that principals can perform on your resources. These operations include specifying which resource types each action can apply to and which principal types can perform each action. In the PhotoFlash application, actions include viewing photos, sharing photos, and commenting on photos. | . Services that use Cedar can use the information provided in the schema to validate the policies you submit to the policy store. This helps prevent your policies from returning incorrect authorization decisions because of errors in policies like incorrectly typed attribute names. For more information about validating your policies, see Cedar policy validation against schema. ",
    "url": "/schema.html#overview",
    
    "relUrl": "/schema.html#overview"
  },"15": {
    "doc": "Schema format",
    "title": "Schema format",
    "content": "A schema contains a declaration of one or more namespaces, each of which contains two mandatory JSON objects, entityTypes and actions. A namespace declaration can optionally include a third object, commonTypes, which defines types that can be referenced by the other two objects. We consider the format of namespaces and these three objects next. ",
    "url": "/schema.html",
    
    "relUrl": "/schema.html"
  },"16": {
    "doc": "Schema format",
    "title": "Namespace",
    "content": "A namespace declaration identifies and defines a scope for all entity types and actions declared within it. The namespace is a string that uses double colons (::) as separators between its elements, which must be identifiers. A namespace can be empty (i.e., the empty string). The namespace name must be normalized and cannot include any embedded whitespace, such as spaces, newlines, control characters, or comments. A namespace declaration contains a comma-separated list of JSON objects within braces { }. The following is an example of a namespace declaration: . \"My::Namespace\": { &lt;JSON object&gt;, ... &lt;JSON object&gt; } . A namespace declaration must contain two child elements, and may contain a third, appearing in any order: . | entityTypes | actions | commonTypes (optional) | . You define the types of your application’s principal and resource entities within the entityTypes element, and the specific actions in the actions element. Principals and resources are separated from actions because actions are defined in the schema as individual discrete elements (each of which has type Action), whereas only the principal and resource entities’ types are defined. In your entity store you create individual principal and resource entities that have these types. Optionally, you can define type names in commonTypes and reference those names as types in the entityTypes and actions elements of your schema. The declared namespace is automatically prepended to all types defined within the associated scope. For example, consider the following schema: . { \"ExampleCo::Database\": { \"entityTypes\": { \"Table\": { ... } }, \"actions\": { \"createTable\": { ... } } } } . Here, the schema is effectively defining the action entity ExampleCo::Database::Action::\"createTable\" and the entity type ExampleCo::Database::Table. You can reference entity types and actions defined in other namespaces of the same schema by using their fully qualified names. For example, here is a schema that declares two namespaces, ExampleCo::Clients and ExampleCo::Furniture, where the second namespace’s entity type Table references the first’s entity type Manufacturer. { \"ExampleCo::Clients\": { \"entityTypes\": { \"Manufacturer\": { ... } }, \"actions\": { ... } }, \"ExampleCo::Furniture\": { \"entityTypes\": { \"Table\": { \"shape\": { \"type\": \"Record\", \"attributes\": { \"manufacturer\": { \"type\": \"Entity\", \"name\": \"ExampleCo::Clients::Manufacturer\" } } } } }, \"actions\": { ... } } } . If you change a declared namespace in your schema you will need to change the entity types appearing in your policies and/or in other namespaces declared in your schema to instead reference the changed namespace. ",
    "url": "/schema.html#namespace",
    
    "relUrl": "/schema.html#namespace"
  },"17": {
    "doc": "Schema format",
    "title": "entityTypes",
    "content": "A collection of the principal and resource entity types supported by your application. The entityTypes element contains a comma-separated list of JSON objects. The high-level structure of an entityTypes entry looks like the following example. \"entityTypes\": { \"EntityTypeName1\": { \"memberOfTypes\": [ \"parentGroupTypeName1\", \"parentGroupTypeName2\", … ], \"shape\": { … } }, \"EntityTypeName2\": { \"memberOfTypes\": [ \"parentGroupTypeName1\", \"parentGroupTypeName2\", … ], \"shape\": { … } } } . Each entry in the entityTypes is a JSON object with the following properties. Entity type name . Specifies the name of the entity type as a string. This type name must be an identifier, which is defined in the Cedar grammar as a sequence of alphanumeric characters, omitting any Cedar reserved words. The entity type name must be normalized and cannot include any embedded whitespace, such as spaces, newlines, control characters, or comments. \"My::Name::Space\": { \"entityTypes\": { \"UserGroup\": { ... } // New entity type name } } . This type name is qualified by its namespace to form a fully qualified entity type which must be used when referencing this type in a policy. \"My::Name::Space::UserGroup\" . memberOfTypes . Specifies a list of entity types that can be direct parents of entities of this type. Values in this list must be valid entity type names declared in the schema. If the memberOfTypes element is empty or not defined, then entities of that entity type can’t have any parents in the entity hierarchy. The following example shows that an entity of type User can have parents of type UserGroup. \"entityTypes\": { \"UserGroup\": { … }, \"User\": { \"memberOfTypes\": [ \"UserGroup\" ], … } } . If the parent type is part of the same namespace as the child type, then you can reference simply the parent type’s name. If the parent type is in a different namespace than the child type, then you must include the parent type’s namespace as part of the reference. The following example references two parent types, both named UserGroup. The first UserGroup is part of the same namespace as the child entity type that this entry is part of. The second UserGroup is defined in the namespace Aws::Cognito::UserPool_1. \"memberOfTypes\": [ \"UserGroup\", \"Aws::Cognito::UserPool_1::UserGroup\" ] . shape . Specifies the shape of the data stored in entities of this type. The shape element, if present, must have type Record, and be accompanied by a description of the entity’s attributes. The following example shows a simple specification of the User entity type. \"User\" : { \"shape\" : { \"type\" : \"Record\", \"attributes\" : { \"name\" : { \"type\" : \"String\" }, \"age\" : { \"type\" : \"Long\" } } } } . Each attribute in the attributes portion of the shape record must follow the format described next. Note that if the shape element is omitted, then entities of the type being defined are assumed to have no data stored with them. This is equivalent to specifying a Record with {} for its attributes. Attribute specifications . Each attribute in a Record is a JSON object that describes one attribute in the record associated with entities of this type. It has the form . \"name\" : { \"type\" : \"Type\" }, . where name is the name of the attribute, and Type is one of the Cedar supported data types, discussed in detail below. You can choose to specify whether an attribute is required or optional. By default, attributes that you define are required. This means that policies that reference this type can assume that the attribute is always present. You can make an attribute optional by adding \"required\": false to the attribute description. Here is an example: . \"jobLevel\": { \"type\": \"Long\", \"required\": false }, . A policy should check for an optional attribute’s presence by using the has operator before trying to access the attribute’s value. If evaluation of a policy results in an attempt to access a non-existent attribute, evaluation fails with an error (which causes the policy to be ignored during authorization, and for a diagnostic to be generated). The validator will flag the potential for such errors to occur. You can choose to explicitly declare that an attribute is mandatory by including \"required\": true (but this is unnecessary as mandatory attributes are the default). Attribute types . Attributes’ type components can be \"String\", \"Long\", \"Boolean\", \"Record\", \"Set\", \"Entity\", or \"Extension\". The first three require no further information to be specified. The latter four are described below. Record . A record attribute has the same JSON format as the entity shape’s record’s attributes. As an example, the following refactors the User entity specification above to have a features attribute that is a Record containing some of the user’s physical features. \"User\" : { \"shape\" : { \"type\" : \"Record\", \"attributes\" : { \"name\" : { \"type\" : \"String\" }, \"features\" : { \"type\": \"Record\", \"attributes\": { \"age\" : { \"type\" : \"Long\" }, \"height\": { \"type\" : \"Long\" }, \"eyecolor\": { \"type\": \"String\" } } } } } } . Entity . For attributes of type \"Entity\", you must also specify a name that identifies the entity type of this attribute. The entity type must be defined in the schema. For example, a resource entity might require an Owner element that specifies a User. \"Document\" : { \"shape\" : { \"type\" : \"Record\", \"attributes\" : { \"Owner\": { \"type\": \"Entity\", \"name\": \"User\" } } } } . Set . For attributes with type \"Set\", you must also specify an element that defines the properties of the members of the set. Each element is a JSON object that describes what each member of the set looks like. An element must contain a structure formatted according to the same rules as an attribute. As an example, consider the following Admins entry which could be part of the shape record of an Account entity type. This Admins element is a set of entities of type User and could be used to define which users have administrator permissions in the account. \"Group\" : { \"shape\" : { \"type\" : \"Record\", \"attributes\": { \"Admins\": { \"type\": \"Set\", \"element\": { \"type\": \"Entity\", \"name\": \"User\" } } } } } . Extension . For attributes of type \"Extension\", you must also specify the name of the specific extension type. There are two extension types: ipaddr for IP address values, and decimal for decimal values. For example, a Network entity may include the IP address of its gateway. \"Network\": { \"shape\": { \"type\": \"Record\", \"attributes\": { \"gateway\": { \"type\": \"Extension\", \"name\": \"ipaddr\" } } } } . ",
    "url": "/schema.html#entitytypes",
    
    "relUrl": "/schema.html#entitytypes"
  },"18": {
    "doc": "Schema format",
    "title": "actions",
    "content": "A collection of the Action entities usable as actions in authorization requests submitted by your application. The actions element contains a comma-separated list of one or more JSON objects. The high-level structure of an actions entry looks like the following. \"actions\": { \"ActionName1\": { \"memberOf\": [\"ActionGroupName1\",...], \"appliesTo\": { \"principalTypes\": [\"PrincipalEntityType1\",...], \"resourceTypes\": [\"ResourceEntityType1\",...], } }, \"ActionName2\": { ... }, ... } . You can add as many actions as your application requires. Action name . Specifies the identifier for the action entity, as a string. The name of the action isn’t a value but the heading for its own JSON object. Since this is an entity identifier (rather than an entity type, as in the entityTypes section) it can contain anything that would be valid inside a Cedar string. \"actions\": { \"ViewPhoto\": { ... }, \"ListPhotos\": { ... }, ... } . You can then refer to these actions in your policies by using the following syntax. If the schema declares a namespace, then the entity type Action is qualified by that namespace. MyApplicationNamespace::Action::\"ViewPhoto\" . memberOf . Specifies a list of action entity groups the action is a member of. The memberOf component is optional. If omitted, it means the action is a member of no action groups. The following schema snippet shows an action named viewAlbum that is a member of the action group called viewImages. \"actions\": { \"viewAlbum\": { … \"memberOf\": [ { \"id\": \"viewImages\", \"type\": \"PhotoFlash::Images::Action\" }, ], … } } . Action groups are themselves actions, and thus must also be defined in the schema in the actions section; we’ll see an example of that below. appliesTo . Specifies a JSON object containing two lists, principalTypes and resourceTypes, which contain the principal and resources entity types, respectively, that can accompany the action in an authorization request. | If the principalTypes component is omitted from the appliesTo element, then an authorization request with this action can have a principal entity of any type, or the unspecified entity. The same is true for resourceTypes, for a request’s resource component. If the appliesTo component is omitted entirely, it’s the same as if it were present with both principalTypes and resourceTypes components omitted (i.e., a request can have both principal and resource entities of any type, or leave them unspecified). | If either the principalTypes or resourceTypes components is given with an empty list [], the associated action is not permitted in an authorization request with any entities of that category. This effectively means that the action will not be used in an authorization request at all. This makes sense for actions that act as groups for other actions. | . The following example actions snippet shows three actions. The first action, read, is an action group for the other two. It cannot appear in an authorization request because its principalTypes and resourceTypes components are []. The second action, viewPhoto, is a member of the read action group, and expects that any request with this action will have a principal entity of type User and a resource entity of type Photo. The third action, listAlbums, also a member of the read group, expects that a request with that action will have a principal entity of type User and a resource entity of type Account. Notice that for both of the latter two actions, the group membership only requires giving the ID of the action – \"read\" – and not the type. This is because the validator knows that all action groups must have type Action, and by default the action will be within the current namespace. To declare membership in an action group in a different namespace you need to include \"type\": \"My::Namespace::Action\" alongside the \"id\" portion, where My::Namespace is the different namespace. \"actions\": { \"read\": { \"appliesTo\": { \"principalTypes\": [], \"resourceTypes\": [] } }, \"viewPhoto\": { \"memberOf\": [ { \"id\": \"read\" } ], \"appliesTo\": { \"principalTypes\": [ \"User\" ], \"resourceTypes\": [ \"Photo\" ] } }, \"listAlbums\": { \"memberOf\": [ { \"id\": \"read\" } ], \"appliesTo\": { \"principalTypes\": [ \"User\" ], \"resourceTypes\": [ \"Account\" ] } } } . context . Specifies a JSON object in the same format as an entity’s shape property, which defines the attributes that can be present in the context record in authorization requests made with this action. Specifying a context enables Cedar to validate policies that attempt to reference the context record’s attributes. Each context entry consists of type and attributes objects. The type object is always the type Record. The attributes object has the same JSON format as the entity shape’s record’s attributes. For example, the following context snippet specifies that any request to perform the SomeAction action must include a Boolean attribute named field1 and a Longattribute named field2. Optionally, the context may include a third attribute field3 which, if present, is a String. The context entry is optional, and if excluded it is assumed to be an empty Record (in which case policies that try to access attributes in context will produce validation errors). \"actions\": { \"SomeAction\": { \"appliesTo\": { \"principalTypes\": [ ... ], \"resourceTypes\": [ ... ], \"context\": { \"type\": \"Record\", \"attributes\": { \"field1\": { \"type\": \"Boolean\" }, \"field2\": { \"type\": \"Long\" }, \"field3\": { \"type\": \"String\", \"required\": false } } } } } } . ",
    "url": "/schema.html#actions",
    
    "relUrl": "/schema.html#actions"
  },"19": {
    "doc": "Schema format",
    "title": "commonTypes",
    "content": "A collection of type names their definitions. These type names can be referenced in the entityTypes and actions portions of the schema wherever a type is expected. Motivation . Suppose your schema defines several entity types or action entities that share a lot of elements in common. For example, consider the following actions: both view and upload have identical context components. \"actions\": { \"view\": { \"appliesTo\": { \"context\": { \"type\": \"Record\", \"attributes\": { \"ip\": { \"type\": \"Extension\", \"name\": \"ipaddr\" }, \"is_authenticated\": { \"type\": \"Boolean\" }, \"timestamp\": { \"type\": \"Long\" } } } } }, \"upload\": { \"appliesTo\": { \"context\": { \"type\": \"Record\", \"attributes\": { \"ip\": { \"type\": \"Extension\", \"name\": \"ipaddr\" }, \"is_authenticated\": { \"type\": \"Boolean\" }, \"timestamp\": { \"type\": \"Long\" } } } } } } . Instead of redundantly entering common type elements separately for each action / entity type that needs them, you can define them once within commonTypes, and then refer to the definition in multiple places. Structure . Each JSON object within commonTypes consists of the name of a type being defined and its associated definition. The definition is specified just like an attribute type specification, i.e., . \"TypeName\": { // attribute type specification } . Returning to our motivating example, we can define a record type called ReusedContext, which is then referenced by the view and upload actions... \"commonTypes\": { \"ReusedContext\": { \"type\": \"Record\", \"attributes\": { \"ip\": { \"type\": \"Extension\", \"name\": \"ipaddr\" }, \"is_authenticated\": { \"type\": \"Boolean\" }, \"timestamp\": { \"type\": \"Long\" } } } }, \"actions\": { \"view\": { \"appliesTo\": { \"context\": { \"type\": \"ReusedContext\" } } }, \"upload\": { \"appliesTo\": { \"context\": { \"type\": \"ReusedContext\" } } } } . We can also use type names defined in commonTypes within definitions in the entityTypes section. As a simple example, here we define a type name as a String, and then use the type (twice) in the User entity type’s attributes specifications: ... \"commonTypes\": { \"name\": { \"type\": \"String\", } }, \"entityTypes\": { \"User\": { \"shape\": { \"type\": \"Record\", \"attributes\": { \"firstName\": { \"type\": \"name\" }, \"lastName\": { \"type\": \"name\" } } } } } . As another example, we can use a defined record type for the shape of multiple entity types. In particular, we collect a set of attributes as a record named Person and use Person within the Employee and Customer entity type definitions... \"commonTypes\": { \"Person\": { \"type\": \"Record\", \"attributes\": { \"age\": {\"type\": \"Long\"}, \"name\": {\"type\": \"String\"} } } }, \"entityTypes\": { \"Employee\": { \"shape\": { \"type\": \"Person\" } }, \"Customer\": { \"shape\": { \"type\": \"Person\" } } } . If you then send an Employee entity as the principal in an authorization request, you could evaluate the attributes of that principal by using syntax similar to this example: principal.age. Note that definitions of types appearing in commonTypes cannot refer to one another. For example, if both name and Person from the above example were in the same commonTypes section, you could not change Person’s define to refer to objects of type name. ",
    "url": "/schema.html#commontypes",
    
    "relUrl": "/schema.html#commontypes"
  },"20": {
    "doc": "Schema format",
    "title": "Example schema",
    "content": "The following schema is for a hypothetical application called PhotoFlash. The schema defines a User entity that can have a department and a jobLevel. The user can be a member of a UserGroup. The schema also defines the following three resource types: . | An Account can have one owner and zero or more admins that are all User entities. | An Album can be nested inside another Album, and has a Boolean private attribute, and a reference to an Account. | A Photo can be placed in an Album, and also has a private attribute and a reference to an Account. | . { \"PhotoFlash\": { \"entityTypes\": { \"User\": { \"memberOfTypes\": [ \"UserGroup\" ], \"shape\": { \"type\": \"Record\", \"attributes\": { \"department\": { \"type\": \"String\" }, \"jobLevel\": { \"type\": \"Long\" } } } }, \"UserGroup\": { }, \"Photo\": { \"memberOfTypes\": [ \"Album\" ], \"shape\": { \"type\": \"Record\", \"attributes\": { \"private\": { \"type\": \"Boolean\" }, \"account\": { \"type\": \"Entity\", \"name\": \"Account\" } } } }, \"Album\": { \"memberOfTypes\": [ \"Album\" ], \"shape\": { \"type\": \"Record\", \"attributes\": { \"private\": { \"type\": \"Boolean\" }, \"account\": { \"type\": \"Entity\", \"name\": \"Account\" } } } }, \"Account\": { \"memberOfTypes\": [], \"shape\": { \"type\": \"Record\", \"attributes\": { \"owner\": { \"type\": \"Entity\", \"name\": \"User\" }, \"admins\": { \"required\": false, \"type\": \"Set\", \"element\": { \"type\": \"Entity\", \"name\": \"User\" } } } } } }, \"actions\": { \"viewPhoto\": { \"appliesTo\": { \"principalTypes\": [ \"User\" ], \"resourceTypes\": [ \"Photo\" ], \"context\": { \"type\": \"Record\", \"attributes\": { \"authenticated\": { \"type\": \"Boolean\" } } } } }, \"listAlbums\": { \"appliesTo\": { \"principalTypes\": [ \"User\" ], \"resourceTypes\": [ \"Account\" ], \"context\": { \"type\": \"Record\", \"attributes\": { \"authenticated\": { \"type\": \"Boolean\" } } } } }, \"uploadPhoto\": { \"appliesTo\": { \"principalTypes\": [ \"User\" ], \"resourceTypes\": [ \"Album\" ], \"context\": { \"type\": \"Record\", \"attributes\": { \"authenticated\": { \"type\": \"Boolean\" }, \"photo\": { \"type\": \"Record\", \"attributes\": { \"file_size\": { \"type\": \"Long\" }, \"file_type\": { \"type\": \"String\" } } } } } } } } } } . ",
    "url": "/schema.html#example-schema",
    
    "relUrl": "/schema.html#example-schema"
  },"21": {
    "doc": "Security",
    "title": "Cedar security",
    "content": "This section provides information about security as it relates to the Cedar policy language. Topics on this page . | Shared responsibility | Security of Cedar | Security of applications using Cedar . | Understanding Cedar semantics | Validating your Cedar policies against your schema | . | Security best practices for applications using Cedar | . ",
    "url": "/security.html#cedar-security",
    
    "relUrl": "/security.html#cedar-security"
  },"22": {
    "doc": "Security",
    "title": "Shared responsibility",
    "content": "Security is a shared responsibility between Cedar and its users. It is the responsibility of Cedar to correctly evaluate policies to arrive at an authorization decision. It is the responsibility of users of Cedar to correctly define policies that implement their authorization model. Although Cedar provides tools such as the policy validator to validate your policies against the schema, it is ultimately the user’s responsibility to write policies correctly. ",
    "url": "/security.html#shared-responsibility",
    
    "relUrl": "/security.html#shared-responsibility"
  },"23": {
    "doc": "Security",
    "title": "Security of Cedar",
    "content": "It is the responsibility of Cedar to implement the Cedar policy language correctly as described in this guide. We, members of the Cedar development team, ensure Cedar’s correctness and security by developing several artifacts: . | A formal model implemented in Dafny. Dafny is an open-source, verification-aware programming language. The Dafny model consists of executable definitions of Cedar’s components which represent the semantics of Cedar, and properties of those components. Dafny verifies that the properties hold. It gives us confidence that our definition of the ground truth is correct. | A production authorization engine written in Rust. We use only the safe subset of Rust, giving us memory safety, type safety, and data-race safety. | A differential testing engine that can test automatically that #1 and #2 have the same semantics. | . In particular, Cedar provides two properties about authorization queries: . | default-deny – Authorization queries result in a Deny unless an explicit permit policy evaluates to true. | forbid-trumps-permit – A single forbid policy evaluating to true results in a Deny. | . ",
    "url": "/security.html#security-of-cedar",
    
    "relUrl": "/security.html#security-of-cedar"
  },"24": {
    "doc": "Security",
    "title": "Security of applications using Cedar",
    "content": "It is the responsibility of applications using Cedar to implement their authorization logic correctly using Cedar policies. To do this, application developers must understand the semantics of Cedar policies. Developers should understand the risks associated with an incorrectly implemented authorization model and take appropriate steps to mitigate those risks. We will provide customers with tools to help them author correct and secure policies, such as policy validation, semantic analysis, and policy templates. Understanding Cedar semantics . To create correct authorization policies, developers must understand the semantics of Cedar. This guide contains a detailed description of every feature of the language and how it is evaluated. It also includes several examples. Developers must understand how the results of evaluating individual policies are combined to reach an authorization decision. In particular, note the following: . | default-deny – Authorization queries will result in a Deny unless an explicit permit policy evaluates to true. | forbid-overrides-permit – A single forbid policy evaluating to true results in a Deny. | An error in a policy results in that policy being ignored for the purpose of an evaluation decision. (skip-on-error semantics) | . Validating your Cedar policies against your schema . Cedar users can check that policies are consistent with a schema. The schema defines the expected structure and type of Cedar entities represented in requests. In particular, the schema defines the set of entity types and how they are used (as actions, principals, or resources), how entities can be grouped into a hierarchy, and what attributes the entities have. Users can validate a policy before adding it to the store. By providing a schema, policies that pass validation don’t result in runtime errors when they are run against schema-compliant entities and requests. The Cedar validator can detect the many types of bugs, including the following: . | Detect unrecognized entity types and actions – For example, misspelling “Album” as “Albom” or “viewPhoto” as “viewPhoot”. | Detect actions being applied to unsupported principals and resources – For example, saying that a Photo can View a User. | Detect improper use of in or == – For example, writing principal in Album::\"trip\" when principal cannot be a Photo. | Detect unrecognized attributes – For example, referencing principal.jobbLevel when the attribute should be jobLevel. | Type mismatches in attributes – For example, principal.hireDate + 3 (Illegal to add integers and dates) | Detect optional attributes referenced without an existence check. – For example, principal.optionalValue &lt; 100 instead of principal has optionalValue &amp;&amp; principal.optionalValue &lt; 100 | Detect invalid parameters to the constructors of extension types. – For example, IP(\"3.45.1111.43\") isn’t a valid IP address. | . Writing a schema and using the policy validator can give you increased confidence that you’ve written your authorization policies correctly. It is your responsibility to write a schema that correctly models your data. It is the responsibility of Cedar to ensure that the validator is correct. We achieve a high confidence in the correctness of the validator by formally modeling it using Dafny. We have proved the correctness of the validation algorithm, and we use differential testing to ensure the production validator matches the behavior of the formal model. For more information, see Cedar policy validation against schema. ",
    "url": "/security.html#security-of-applications-using-cedar",
    
    "relUrl": "/security.html#security-of-applications-using-cedar"
  },"25": {
    "doc": "Security",
    "title": "Security best practices for applications using Cedar",
    "content": "Some security best practices for applications that use Cedar are as follows: . | Policies should follow the principle of least privilege. Grant only the permissions required to perform the task at hand. | Be careful about who you allow to modify your policies. We’ve endeavored to make Cedar a safe environment in which to evaluate policies, there are always risks when it comes to running arbitrary code submitted by users. Here are a few things to keep in mind if you plan on evaluating arbitrary cedar policies submitted by end users. | Cedar has no facilities for I/O, so Cedar policies are unable to perform activities like reading files or talking to the network. | The evaluation of one Cedar policy can’t effect the evaluation of another policy. | While all Cedar policies are guaranteed to terminate, a malicious user could attempt to submit very lengthy policies, incurring either storage or performance costs. If you are evaluating arbitrary Cedar policies, we recommend that you put a length limit in place. | Cedar provides on authorization – determining what an authenticated user can do. However, Cedar does not perform authentication – verifying the identity of the users who attempt to access your application. You application must provide authentication services separately and then proceed with authorization of only successfully authenticated users. | . | Write a schema and have Cedar validate it to ensure your authorization policies don’t encounter runtime errors. | Put all authorization logic in your Cedar policies. Don’t spread authorization logic around different locations in your application. | Use policy templates where applicable to avoid duplicating authorization logic. This approach also provides a single location for future changes. (Don’t-Repeat-Yourself) . | If you create policies dynamically, avoid using string concatenation. Instead, use policy templates. Creating policies with string concatenation is error-prone and insecure. If an attacker gained control of the inputs to concatenation, they could achieve code injection. Here, “code injection” refers to injection of Cedar code, not arbitrary code execution. It is the responsibility of the Cedar library to prevent arbitrary code injection. For example, consider a policy dynamically created as shown here: . let src = \"permit(\" + input + \", Action::\\\"view\\\", resource) when { principal.level &gt; 3 };\"let policy = parse(src);addToPolicySet(policy); . You could provide a good value for input, such as User::\"alice\". That value works fine and produces the following policy in variable src. permit(User::\"alice\", Action::\"view\", resource) when { principal.level &gt; 3 }; . But, if an attacker could somehow control the value for input, they could achieve Cedar code injection. For example, if the attacker set input to the following. \"principal,action,resource); //\" . The completed policy in src would look like the following example. \"permit(principal,action,resource); //,Action::{\\\"view\\\", resource) when { principal.level &gt; 3 }; . That policy permits all actions on all resources by anyone, regardless of level. | Use unique, immutable, and non-recyclable IDs for entity identifiers. An example of a mutable identifier is a username or group name in a workforce directory, where the value of the name can change. For example, consider the following policy. permit (principal == User::\"alice\",action in ...,resource in ...); . Imagine that Alice leaves the organization, and another user named Alice joins the organization. If the new Alice reuses the “alice” username, then she would attain the permissions of any lingering policies that hadn’t been removed. For these reasons, policies must refer to only unique, normalized, immutable, and non-recyclable identifiers. We recommend that you use UUIDs or similar formats that meet the same criteria, such as sequence numbers or URNs. permit ( principal == User::\"2dad2883-cba1-4a1e-b212-a6c0a5290dad\", // \"Alice\" action in ..., resource in ... ); . | Ensure that data used for authorization decisions, such as policies, entities, or context information, can’t be accessed or modified by potential attackers. | Normalize input data prior to invoking the authorization APIs. | . ",
    "url": "/security.html#security-best-practices-for-applications-using-cedar",
    
    "relUrl": "/security.html#security-best-practices-for-applications-using-cedar"
  },"26": {
    "doc": "Security",
    "title": "Security",
    "content": " ",
    "url": "/security.html",
    
    "relUrl": "/security.html"
  },"27": {
    "doc": "Data types",
    "title": "Data types supported by Cedar",
    "content": "The Cedar policy language supports values and expressions of the following data types. Topics on this page . | Boolean | String | Long | Set | Record | Entity | Extension . | decimal | ipaddr | . | . ",
    "url": "/syntax-datatypes.html#data-types-supported-by-cedar",
    
    "relUrl": "/syntax-datatypes.html#data-types-supported-by-cedar"
  },"28": {
    "doc": "Data types",
    "title": "Boolean",
    "content": "A value that is either true or false. ",
    "url": "/syntax-datatypes.html#boolean",
    
    "relUrl": "/syntax-datatypes.html#boolean"
  },"29": {
    "doc": "Data types",
    "title": "String",
    "content": "A sequence of characters consisting of letters, numbers, or symbols. Cedar doesn’t have a string length limit, but services that use Cedar are likely to have limits for each element with a value of type String. ",
    "url": "/syntax-datatypes.html#string",
    
    "relUrl": "/syntax-datatypes.html#string"
  },"30": {
    "doc": "Data types",
    "title": "Long",
    "content": "A whole number without decimals that can range from -9223372036854775808 to 9223372036854775807. ",
    "url": "/syntax-datatypes.html#long",
    
    "relUrl": "/syntax-datatypes.html#long"
  },"31": {
    "doc": "Data types",
    "title": "Set",
    "content": "A collection of elements that can be of the same or different types. A set is constructed using bracket characters [ ] and separating the elements with commas. The following examples show a few sets. // a set of three elements, two of type long, and one of type string [2, 4, \"hello\"] // a set of a single type long [-1] // an empty set [ ] // a set with a Boolean expression, a nested set, and a Boolean value [3&lt;5, [\"nested\", \"set\"], true] . ",
    "url": "/syntax-datatypes.html#set",
    
    "relUrl": "/syntax-datatypes.html#set"
  },"32": {
    "doc": "Data types",
    "title": "Record",
    "content": "A collection of attributes. Each attribute consists of a name and an associated value. Names are simple strings. Values can be of any type. You can access an attribute’s value by referencing its name as an index using either of the following syntax options: . | record[\"attributename\"] | record.attributename | . The following example shows the correct syntax for a Record. {\"key\": \"some value\", id:\"another value\" } . You can reference the first attribute as either record[\"key\"] or record.key. Both options evaluate to \"some value\". Records can also be nested. To access them use any of the following options: . | All using [] – record[\"some\"][\"nested\"][\"attribute\"] | All using . – record.some.nested.attribute | A mix of both – record[\"some\"].nested[\"attribute\"] | . The following are additional examples of records. {} {\"foo\": 2, bar: [3, 4, -47], ham: \"eggs\", \"hello\": true } . ",
    "url": "/syntax-datatypes.html#record",
    
    "relUrl": "/syntax-datatypes.html#record"
  },"33": {
    "doc": "Data types",
    "title": "Entity",
    "content": "An entity represents a principal, action, or resource in your authorization model. A principal represents an actor in your application, such as a user, or a service that can perform actions. Your application can define the available actions, such as creating, reading, writing, or deleting. Resources contain your data and are acted upon by the principals using the defined actions. Entities are specified by identifying the type of entity, including the namespace if required, followed by two colon characters ( :: ) and the unique identifier assigned to this specific entity. namespace::type::\"unique-identifier\" . // A resource of type File File::\"myfile.txt\" // An action to allow reading a resource of type File Action::\"ReadFile\" // A principal of type User with a full UUID as // the entity identifier and its friendly name in comments User::\"a1b2c3d4-e5f6-a1b2-c3d4-EXAMPLE11111\" . This guide includes examples that use simple entity identifiers, such as jane or bob for the name of an entity of type User. This is done to make the examples more readable. However, in a production system it is critical for security reasons that you use unique values that can’t be reused. We recommend that you use values like universally unique identifiers (UUIDs). For example, if user jane leaves the company, and you later let someone else use the name jane, then that new user automatically gets access to everything granted by policies that still reference User::\"jane\". Cedar can’t distinguish between the new user and the old. This applies to both principal and resource identifiers. Always use identifiers that are guaranteed unique and never reused to ensure that you don’t unintentionally grant access because of the presence of an old identifier in a policy. Where you use a UUID for an entity, we recommend that you follow it with the // comment specifier and the ‘friendly’ name of your entity. This helps to make your policies easier to understand. For example: . principal == User::\"a1b2c3d4-e5f6-a1b2-c3d4-EXAMPLE11111\", // alice . ",
    "url": "/syntax-datatypes.html#entity",
    
    "relUrl": "/syntax-datatypes.html#entity"
  },"34": {
    "doc": "Data types",
    "title": "Extension",
    "content": "The remaining Cedar data types are introduced as extension types. Values of an extension type are introduced by calling a constructor function that takes a string as its parameter. Operations on extension types, aside from equality, use a function- or method-call syntax. Equality testing uses == as usual. As of now Cedar supports two extension types: decimal and ipaddr. decimal . A value with both a whole number part and a decimal part of no more than four digits. You specify values of extension type decimal by using the decimal() function, e.g., . decimal(\"12345.1234\") . (You can’t specify a decimal as a simple literal.) . A decimal value can range from -922337203685477.5808 to 922337203685477.5807. ipaddr . A value that represents an IP address. It can be either IPv4 or IPv6. The value can represent an individual address or a range of addresses, by adding a CIDR suffix (a slash / and an integer) after the address. You specify values of extension type ipaddr using the ip() operator. Here are some examples: . ip(\"192.168.1.100\") // a single IPv4 address ip(\"10.50.0.0/24\") // an IPv4 range with a 24-bit subnet mask (255.255.0.0) ip(\"1:2:3:4::/48\") // an IPv6 range with a 48-bit subnet mask . ",
    "url": "/syntax-datatypes.html#extension",
    
    "relUrl": "/syntax-datatypes.html#extension"
  },"35": {
    "doc": "Data types",
    "title": "Data types",
    "content": " ",
    "url": "/syntax-datatypes.html",
    
    "relUrl": "/syntax-datatypes.html"
  },"36": {
    "doc": "Entity",
    "title": "Entities in Cedar",
    "content": "An entity in Cedar is a stored object that serves as the representation for principals, actions, and resources that are part of your application. Topics on this page . | Overview of entities | Operators | Namespaces | Attributes of entities | . ",
    "url": "/syntax-entity.html#entities-in-cedar",
    
    "relUrl": "/syntax-entity.html#entities-in-cedar"
  },"37": {
    "doc": "Entity",
    "title": "Overview of entities",
    "content": "An entity in Cedar has the following components. | An entity type – The type determines which attributes are required or supported for entities of that type. Examples include things like User, Photo, Album, Group, or Account. Define entity types as part of your application’s schema. | An entity identifier (EID) – The EID lets you reference a specific entity in your policy. The combination of entity type and an EID uniquely identifies an object for Cedar. This guide includes examples that use simple entity identifiers, such as jane or bob for the name of an entity of type User. This is done to make the examples more readable. However, in a production system it is critical for security reasons that you use unique values that can’t be reused. We recommend that you use values like universally unique identifiers (UUIDs). For example, if user jane leaves the company, and you later let someone else use the name jane, then that new user automatically gets access to everything granted by policies that still reference User::\"jane\". Cedar can’t distinguish between the new user and the old. This applies to both principal and resource identifiers. Always use identifiers that are guaranteed unique and never reused to ensure that you don’t unintentionally grant access because of the presence of an old identifier in a policy. Where you use a UUID for an entity, we recommend that you follow it with the // comment specifier and the ‘friendly’ name of your entity. This helps to make your policies easier to understand. For example: . principal == User::\"a1b2c3d4-e5f6-a1b2-c3d4-EXAMPLE11111\", // alice . | Attributes – Zero or more attributes that can be of any data type supported by Cedar. For example, an entity of type Photo might contain attributes like a name (a string), a createdDate (a string containing a date), a location (a set of type Decimal that represent coordinates), and the photographer (a reference to another entity representing the user who took the photo). Define the attributes relevant to an entity type as part of your application’s schema. | . Entities can be grouped into logical hierarchies. You create a hierarchy by specifying a parent attribute that points to the group of which the entity is a member. Hierarchies allow you to arrange your entities according to the requirements of your scenario. For example, if your application has an entity that represents a Photo, then you can arrange those photos into one or more Album groups. An entity can have multiple parent entities, and entities can be nested. For example, you could define an Album called trips that is the parent of another Album called vacations. That Album could then be the parent of several Photo entities. A photo in the Vacations album could at the same time also be in an album named picturesOfBob. To do this, you simply designate an additional parent attribute to the photo that points to the additional album. You can use as many types of entities as your scenario requires. We recommend that you define these formally by using a schema. This general structure lets Cedar support scenarios where a single entity type can perform in multiple roles. For example, consider a user directory, such as an LDAP system. Such a user directory must support fine-grained permissions to restrict who can read and write the contents of the directory. A policy in such a situation might need to express concepts like the following: . | Any user can read their own data. | Any user who belongs to the Human Resources department can update the information for any other users. | . In these scenarios, both the principal and the resource can be the same type of entity, or even the same user. // Allow every user to read their own data in the user directory permit ( principal, action == Action::\"readUser\", resource ) when { principal == resource //The same entity }; . This example allows any principal to perform the readUser action on any resource, as long as the principal and the resource in the request are the same entity. Except for action entities, which are prefixed with the reserved keyword action, there is no way to distinguish whether an entity should behave as a principal, resource, or both without additional context. You can use entity types to constrain how an entity type can be used. ",
    "url": "/syntax-entity.html#overview-of-entities",
    
    "relUrl": "/syntax-entity.html#overview-of-entities"
  },"38": {
    "doc": "Entity",
    "title": "Operators",
    "content": "Entities support the following operators in a Cedar policy: . | Equality – Using the == operator, you can compare two entities to see if they are the same. Equality in this context means that they are literally the same entity and have the same unique entity identifier. For more information, see == equality operator. | Hierarchy / membership – Using the in operator, you can determine if one entity is a descendant of (or a member of) another entity’s hierarchy. For more information, see in operator. | Attribute presence – Using the has operator, you can determine if the entity has a specific attribute. You can use this operator to ensure that an attribute is present before attempting to access its value. If you attempt to access an attribute that doesn’t exist for the specified entity, it generates an error. | Attribute access – Using the . operator, you can retrieve the value of one of the entity’s attributes using the syntax entityName.attributeName. You can define the attributes supported by your entities as part of the schema. | . ",
    "url": "/syntax-entity.html#operators",
    
    "relUrl": "/syntax-entity.html#operators"
  },"39": {
    "doc": "Entity",
    "title": "Namespaces",
    "content": "An entity can also be referenced in the context of multiple namespaces. This capability lets you infer a logical hierarchy of entity types. For example, PhotoFlash::Groups::Album::\"vacation\" refers to a specific entity with an entity ID of \"vacation\" and an entity type of PhotoFlash::Groups::Album. There is no real structure behind such a string, only what is logically inferred by the designer. You can create namespaces for an entity type when you define a schema. ",
    "url": "/syntax-entity.html#namespaces",
    
    "relUrl": "/syntax-entity.html#namespaces"
  },"40": {
    "doc": "Entity",
    "title": "Attributes of entities",
    "content": "An attribute is an additional detail about an entity. For example, a user typically has a name. An employee in a company can have an assigned department. A photo can have a description. Attributes are referenced by using dot operator notation (entity.attribute), as shown by the following examples. SomeUser.name //SomeUser is an entity of type user SomeEmployee.department //SomeEmployee is an entity of type employee SomePhoto.description //SomePhoto is an entity of type photo. Alternatively, you can reference an entity’s attributes by using indexing notation (entity[\"attribute\"]), as shown by the following examples which are equivalent to the preceding examples. SomeUser[\"name\"] SomeEmployee[\"department\"] SomePhoto[\"description\"] . An attribute resolves to a value of a supported datatype. The attribute can be referenced anywhere that a value of that datatype is valid. ",
    "url": "/syntax-entity.html#attributes-of-entities",
    
    "relUrl": "/syntax-entity.html#attributes-of-entities"
  },"41": {
    "doc": "Entity",
    "title": "Entity",
    "content": " ",
    "url": "/syntax-entity.html",
    
    "relUrl": "/syntax-entity.html"
  },"42": {
    "doc": "Grammar",
    "title": "Grammar specification for Cedar",
    "content": "This topic describes the grammar specification for the Cedar Policy Language. This grammar uses the following symbols: . | A vertical bar | designates alternatives. Only one alternative can be used. | Brackets [ ] designate an optional element. | Parentheses ( ) designate grouping | Braces { } designate repetition of an element zero or more times. | . Capitalized words represent grammar constructs, and lexical tokens are displayed in all-caps. Tokens are defined using regular expressions: . | Brackets [ ] represent a range of characters. | A vertical bar | designates alternatives. | An asterisk * represents zero or more occurrences of an element. | A plus sign + represents one or more occurrences of an element. | A question mark ? represents exactly zero or one occurrences of an element. | A tilde ~ represents the complement of the following element. | A hyphen - represents difference. | Single quotation marks ' ' surround elements that must be entered literally as shown. | . The grammar ignores whitespace and comments. ",
    "url": "/syntax-grammar.html#grammar-specification-for-cedar",
    
    "relUrl": "/syntax-grammar.html#grammar-specification-for-cedar"
  },"43": {
    "doc": "Grammar",
    "title": "Policy",
    "content": "A policy consists of optional ‘Annotation’ entries, an Effect, a Scope in parentheses ( ), and an optional set of Conditions in braces { }. A policy must always end with a semicolon ;. Policy := {Annotation} Effect '(' Scope ')' {Conditions} ';' . ",
    "url": "/syntax-grammar.html#policy",
    
    "relUrl": "/syntax-grammar.html#policy"
  },"44": {
    "doc": "Grammar",
    "title": "Effect",
    "content": "The Effect element of a policy is either the word permit or forbid. Effect := 'permit' | 'forbid' . ",
    "url": "/syntax-grammar.html#effect",
    
    "relUrl": "/syntax-grammar.html#effect"
  },"45": {
    "doc": "Grammar",
    "title": "Scope",
    "content": "The Scope element of a policy must include a Principal entity, an Action entity, and a Resource entity. Scope := Principal ',' Action ',' Resource . ",
    "url": "/syntax-grammar.html#scope",
    
    "relUrl": "/syntax-grammar.html#scope"
  },"46": {
    "doc": "Grammar",
    "title": "Principal",
    "content": "The Principal element consists of the principal keyword. If specified by itself, the policy statement matches any principal. Optionally, the keyword can be followed by either the in or == operator, followed by either an Entity, or the ?principal placeholder when used in a policy template. Principal := 'principal' [('in' | '==') (Entity | '?principal')] . ",
    "url": "/syntax-grammar.html#principal",
    
    "relUrl": "/syntax-grammar.html#principal"
  },"47": {
    "doc": "Grammar",
    "title": "Action",
    "content": "The Action element consists of the action keyword. If specified by itself, it matches any action. Optionally, it can be followed by either the == operator and an action entity, or in followed by an action entity or a set of action entities. Action := 'action' [( '==' Entity | 'in' ('[' EntList ']' | Entity) )] . ",
    "url": "/syntax-grammar.html#action",
    
    "relUrl": "/syntax-grammar.html#action"
  },"48": {
    "doc": "Grammar",
    "title": "Resource",
    "content": "The Resource consists of the resource keyword. If specified by itself, it matches any resource. Optionally, it can be followed by either the in or == operator, followed by an entity, or the ?resource placeholder when used in a policy template. Resource := 'resource' [('in' | '==') (Entity | '?resource')] . ",
    "url": "/syntax-grammar.html#resource",
    
    "relUrl": "/syntax-grammar.html#resource"
  },"49": {
    "doc": "Grammar",
    "title": "Condition",
    "content": "A Condition consists of either the when or unless keyword followed by a Boolean expression surrounded by braces { }. A when clause matches the request when the expression evaluates to true. An unless clause matches the request when the expression (an Expr element) evaluates to false. The parent Policy element can have zero or more when or unless clauses. Condition := ('when' | 'unless') '{' Expr '}' . ",
    "url": "/syntax-grammar.html#condition",
    
    "relUrl": "/syntax-grammar.html#condition"
  },"50": {
    "doc": "Grammar",
    "title": "Expr",
    "content": "Expr := Or | 'if' Expr 'then' Expr 'else' Expr . ",
    "url": "/syntax-grammar.html#expr",
    
    "relUrl": "/syntax-grammar.html#expr"
  },"51": {
    "doc": "Grammar",
    "title": "Or",
    "content": "Or := And {'||' And} . For more details, see || (OR). ",
    "url": "/syntax-grammar.html#or",
    
    "relUrl": "/syntax-grammar.html#or"
  },"52": {
    "doc": "Grammar",
    "title": "And",
    "content": "And := Relation {'&amp;&amp;' Relation} . For more details, see &amp;&amp; (AND). ",
    "url": "/syntax-grammar.html#and",
    
    "relUrl": "/syntax-grammar.html#and"
  },"53": {
    "doc": "Grammar",
    "title": "Relation",
    "content": "Relation := Add [RELOP Add] | Add 'has' (IDENT | STR) | Add 'like' PAT . ",
    "url": "/syntax-grammar.html#relation",
    
    "relUrl": "/syntax-grammar.html#relation"
  },"54": {
    "doc": "Grammar",
    "title": "Add",
    "content": "Add := Mult {('+' | '-') Mult} . ",
    "url": "/syntax-grammar.html#add",
    
    "relUrl": "/syntax-grammar.html#add"
  },"55": {
    "doc": "Grammar",
    "title": "Mult",
    "content": "Mult := Unary { '*' Unary} . Cedar places a syntactic constraint on the multiplication operation. At most, one of the operands can be something other than an integer literal. For example, 1 * 2 * context.value * 3 is allowed. However, context.laptopValue * principal.numOfLaptops isn’t allowed. ",
    "url": "/syntax-grammar.html#mult",
    
    "relUrl": "/syntax-grammar.html#mult"
  },"56": {
    "doc": "Grammar",
    "title": "Unary",
    "content": "Unary := ['!' | '-']x4 Member . ",
    "url": "/syntax-grammar.html#unary",
    
    "relUrl": "/syntax-grammar.html#unary"
  },"57": {
    "doc": "Grammar",
    "title": "Member",
    "content": "Member := Primary {Access} . ",
    "url": "/syntax-grammar.html#member",
    
    "relUrl": "/syntax-grammar.html#member"
  },"58": {
    "doc": "Grammar",
    "title": "Annotation",
    "content": "Annotation := '@'IDENT'('STR')' . ",
    "url": "/syntax-grammar.html#annotation",
    
    "relUrl": "/syntax-grammar.html#annotation"
  },"59": {
    "doc": "Grammar",
    "title": "Access",
    "content": "Access := '.' IDENT ['(' [ExprList] ')'] | '[' STR ']' . ",
    "url": "/syntax-grammar.html#access",
    
    "relUrl": "/syntax-grammar.html#access"
  },"60": {
    "doc": "Grammar",
    "title": "Primary",
    "content": "Primary := LITERAL | VAR | Entity | ExtFun '(' [ExprList] ')' | '(' Expr ')' | '[' [ExprList] ']' | '{' [RecInits] '}' . ",
    "url": "/syntax-grammar.html#primary",
    
    "relUrl": "/syntax-grammar.html#primary"
  },"61": {
    "doc": "Grammar",
    "title": "Path",
    "content": "Path := IDENT {'::' IDENT} . ",
    "url": "/syntax-grammar.html#path",
    
    "relUrl": "/syntax-grammar.html#path"
  },"62": {
    "doc": "Grammar",
    "title": "Entity",
    "content": "Entity := Path '::' STR . ",
    "url": "/syntax-grammar.html#entity",
    
    "relUrl": "/syntax-grammar.html#entity"
  },"63": {
    "doc": "Grammar",
    "title": "EntList",
    "content": "EntList := Entity {',' Entity} . ",
    "url": "/syntax-grammar.html#entlist",
    
    "relUrl": "/syntax-grammar.html#entlist"
  },"64": {
    "doc": "Grammar",
    "title": "ExprList",
    "content": "ExprList := Expr {',' Expr} . ",
    "url": "/syntax-grammar.html#exprlist",
    
    "relUrl": "/syntax-grammar.html#exprlist"
  },"65": {
    "doc": "Grammar",
    "title": "ExtFun",
    "content": "ExtFun := [Path '::'] IDENT . ",
    "url": "/syntax-grammar.html#extfun",
    
    "relUrl": "/syntax-grammar.html#extfun"
  },"66": {
    "doc": "Grammar",
    "title": "RecInits",
    "content": "RecInits := (IDENT | STR) ':' Expr {',' (IDENT | STR) ':' Expr} . ",
    "url": "/syntax-grammar.html#recinits",
    
    "relUrl": "/syntax-grammar.html#recinits"
  },"67": {
    "doc": "Grammar",
    "title": "RELOP",
    "content": "RELOP := '&lt;' | '&lt;=' | '&gt;=' | '&gt;' | '!=' | '==' | 'in' . ",
    "url": "/syntax-grammar.html#relop",
    
    "relUrl": "/syntax-grammar.html#relop"
  },"68": {
    "doc": "Grammar",
    "title": "IDENT",
    "content": "IDENT := ['_''a'-'z''A'-'Z']['_''a'-'z''A'-'Z''0'-'9']* - RESERVED . ",
    "url": "/syntax-grammar.html#ident",
    
    "relUrl": "/syntax-grammar.html#ident"
  },"69": {
    "doc": "Grammar",
    "title": "STR",
    "content": "STR := Fully-escaped Unicode surrounded by '\"'s . ",
    "url": "/syntax-grammar.html#str",
    
    "relUrl": "/syntax-grammar.html#str"
  },"70": {
    "doc": "Grammar",
    "title": "PAT",
    "content": "PAT := STR with `\\*` allowed as an escape . ",
    "url": "/syntax-grammar.html#pat",
    
    "relUrl": "/syntax-grammar.html#pat"
  },"71": {
    "doc": "Grammar",
    "title": "LITERAL",
    "content": "LITERAL := BOOL | INT | STR . ",
    "url": "/syntax-grammar.html#literal",
    
    "relUrl": "/syntax-grammar.html#literal"
  },"72": {
    "doc": "Grammar",
    "title": "BOOL",
    "content": "BOOL := 'true' | 'false' . ",
    "url": "/syntax-grammar.html#bool",
    
    "relUrl": "/syntax-grammar.html#bool"
  },"73": {
    "doc": "Grammar",
    "title": "INT",
    "content": "INT := '-'? ['0'-'9']+ . ",
    "url": "/syntax-grammar.html#int",
    
    "relUrl": "/syntax-grammar.html#int"
  },"74": {
    "doc": "Grammar",
    "title": "RESERVED",
    "content": "RESERVED := BOOL | 'if' | 'then' | 'else' | 'in' | 'like' | 'has' . ",
    "url": "/syntax-grammar.html#reserved",
    
    "relUrl": "/syntax-grammar.html#reserved"
  },"75": {
    "doc": "Grammar",
    "title": "VAR",
    "content": "VAR := 'principal' | 'action' | 'resource' | 'context' . ",
    "url": "/syntax-grammar.html#var",
    
    "relUrl": "/syntax-grammar.html#var"
  },"76": {
    "doc": "Grammar",
    "title": "WHITESPC",
    "content": "WHITESPC := Unicode whitespace . ",
    "url": "/syntax-grammar.html#whitespc",
    
    "relUrl": "/syntax-grammar.html#whitespc"
  },"77": {
    "doc": "Grammar",
    "title": "COMMENT",
    "content": "COMMENT := '//' ~NEWLINE* NEWLINE . ",
    "url": "/syntax-grammar.html#comment",
    
    "relUrl": "/syntax-grammar.html#comment"
  },"78": {
    "doc": "Grammar",
    "title": "Grammar",
    "content": " ",
    "url": "/syntax-grammar.html",
    
    "relUrl": "/syntax-grammar.html"
  },"79": {
    "doc": "Operators",
    "title": "Operators and functions to use in Cedar",
    "content": "This topic describes the built-in operators and functions that you can use to build your expressions using the Cedar policy language. Topics on this page . | Overview of operators | String operators and functions . | like (string matching with wildcard) . | More Examples: | . | decimal() (parse string and convert to decimal) . | Examples: | . | ip() (parse string and convert to ipaddr) | . | Comparison operators and functions . | == (equality) . | Examples: | . | != (inequality) . | Example: | . | &lt; (long integer ‘less than’) . | Examples: | . | .lessThan() (decimal ‘less than’) . | Examples: | . | &lt;= (long integer ‘less than or equal’) . | Examples: | . | .lessThanOrEqual() (decimal ‘less than or equal’) . | Examples: | . | &gt; (long integer ‘greater than’) . | Examples: | . | .greaterThan() (decimal ‘greater than or equal’) . | Examples: | . | &gt;= (Long integer ‘greater than or equals’) . | Examples: | . | .greaterThanOrEqual() (decimal ‘greater than or equal’) . | Examples: | . | . | Logical operators . | &amp;&amp; (AND) . | More Examples: | . | || (OR) . | More Examples: | . | ! (NOT) . | Example: | More Examples: | . | . | Arithmetic operators . | + (Numeric addition) . | Example: | Other examples: | . | - (Numeric subtraction or negation) . | Examples: | Examples: | . | * (Numeric multiplication) . | Examples: | . | . | Hierarchy and set membership operators and functions . | in (Hierarchy membership) . | Examples: | More examples: | More Examples: | . | has (presence of attribute test) | .contains() (single element set membership test) . | Examples: | . | .containsAll() (all element set membership test) | .containsAny() (any element set membership test) | . | IP address functions . | .isIpv4() (IPv4 address valid test) | .isIpv6() (IPv6 address valid test) | .isLoopback() (test for IP loopback address) | .isMulticast() (test for multicast address) | .isInRange() (test for inclusion in IP address range) | . | . ",
    "url": "/syntax-operators.html#operators-and-functions-to-use-in-cedar",
    
    "relUrl": "/syntax-operators.html#operators-and-functions-to-use-in-cedar"
  },"80": {
    "doc": "Operators",
    "title": "Overview of operators",
    "content": "The operators use the following syntax structures: . | Unary operators – A unary operator takes one operand. Place the operand after the operator. &lt;operator&gt; operand // Uses the logical NOT operator and evaluates to the // inverse of the value of the Boolean operand ! a . | Binary operators – A binary operator takes two operands. Place one operand before the operator and one after. Some binary operators are commutative. See the description of each operator to understand where operand order matters. firstOperand &lt;operator&gt; secondOperand // Evaluates to true if both operands have the same type and value a == b // Evaluates to true if the first operand is within the // hierarchy of the second operand c in d . | . Functions use the following syntax: . | Functions can support zero or more operands. Append the function name to the end of the entity name, separating them with a . (period) character. Place any operands in parentheses after the function name, separating them with commas. entity.function(firstOperand, secondOperand, …) // Evaluates to true if the any of the set member // elements b, c, or d is an element of set a a.containsAny([b, c, d]) . | . ",
    "url": "/syntax-operators.html#overview-of-operators",
    
    "relUrl": "/syntax-operators.html#overview-of-operators"
  },"81": {
    "doc": "Operators",
    "title": "String operators and functions",
    "content": "Use these operators and functions to compare strings or convert them to other types. like (string matching with wildcard) . Usage: &lt;string&gt; like &lt;string with wildcards&gt; . Binary operator that evaluates to true if the string in the left operand matches the pattern string in the right operand. The pattern string can include one or more asterisks (*) as wildcard characters that match 0 or more of any character. To match a literal asterisk character, use the escaped \\* sequence in the pattern string. Consider a query with the following context: . \"context\": { \"location\": \"s3://bucketA/redTeam/some/thing/*\" } . In that scenario, the following expression returns true. context.location like \"s 3:*\" //true . More Examples: . \"eggs\" like \"ham*\" //false \"eggs\" like \"*ham\" //false \"eggs\" like \"*ham*\" //false \"ham and eggs\" like \"ham*\" //true \"ham and eggs\" like \"*ham\" //false \"ham and eggs\" like \"*ham*\" //true \"ham and eggs\" like \"*h*a*m*\" //true \"eggs and ham\" like \"ham*\" //false \"eggs and ham\" like \"*ham\" //true \"eggs, ham, and spinach\" like \"ham*\" //false \"eggs, ham, and spinach\" like \"*ham\" //false \"eggs, ham, and spinach\" like \"*ham*\" //true \"Gotham\" like \"ham*\" //false \"Gotham\" like \"*ham\" //true \"ham\" like \"ham\" //true \"ham\" like \"ham*\" //true \"ham\" like \"*ham\" //true \"ham\" like \"*h*a*m*\" //true \"ham and ham\" like \"ham*\" //true \"ham and ham\" like \"*ham\" //true \"ham\" like \"*ham and eggs*\" //false \"\\\\afterslash\" like \"\\\\*\" //true \"string\\\\with\\\\backslashes\" like \"string\\\\with\\\\backslashes\" //true \"string\\\\with\\\\backslashes\" like \"string*with*backslashes\" //true \"string*with*stars\" like \"string\\*with\\*stars\" //true . decimal() (parse string and convert to decimal) . Usage: decimal(&lt;string&gt;) . Function that parses the string and tries to convert it to type decimal. If the string doesn’t represent a valid decimal value, it generates an error. To be interpreted successfully as a decimal value, the string must contain a decimal separator (.) and at least one digit before and at least one digit after the separator. There can be no more than 4 digits after the separator. The value must be within the valid range of the decimal type, from -922337203685477.5808 to 922337203685477.5807. Examples: . decimal(\"1.0\") decimal(\"-1.0\") decimal(\"123.456\") decimal(\"0.1234\") decimal(\"-0.0123\") decimal(\"55.1\") decimal(\"00.000\") decimal(\"1234\") //error decimal(\"1.0.\") //error decimal(\"1.\") //error decimal(\".1\") //error decimal(\"1.a\") //error decimal(\"-.\") //error decimal(\"1000000000000000.0\") //overflow decimal(\"922337203685477.5808\") //overflow decimal(\"0.12345\") //error decimal(\"0.00000\") //error . ip() (parse string and convert to ipaddr) . Usage: ip(&lt;string&gt;) . Function that parses the string and attempts to convert it to type ipaddr. If the string doesn’t represent a valid IP address or range, then it generates an error. ip(\"127.0.0.1\") ip(\"::1\") ip(\"127.0.0.1/24\") ip(\"ffee::/64\") ip(\"ff00::2\") ip(\"::2\") ip(\"380.0.0.1\") //error – invalid IPv4 address ip(\"ab.ab.ab.ab\") //error – invalid IPv4 address ip(\"127.0.0.1/8/24\") //error – invalid CIDR notation ip(\"fee::/64::1\") //error – invalid IPv6 address ip(\"fzz::1\") //error – invalid character in address ip([127,0,0,1]) //error – invalid type \"127.0.0.1\".ip() //error – invalid call style ip(\"127.0.0.1\") == ip(\"127.0.0.1\") //true ip(\"192.168.0.1\") == ip(\"8.8.8.8\") //false ip(\"192.168.0.1/24\") == ip(\"8.8.8.8/8\") //false ip(\"192.168.0.1/24\") == ip(\"192.168.0.8/24\") //true ip(\"127.0.0.1\") == ip(\"::1\") //false – different IP versions ip(\"127.0.0.1\") == \"127.0.0.1\" //false – different types ip(\"::1\") == 1 //false – different types ip(\"127.0.0.1\") == ip(\"192.168.0.1/24\") //false - address compared to range ip(\"127.0.0.1\") &lt; ip(\"10.0.0.10\") //error – invalid data types for &lt; operator . ",
    "url": "/syntax-operators.html#string-operators-and-functions",
    
    "relUrl": "/syntax-operators.html#string-operators-and-functions"
  },"82": {
    "doc": "Operators",
    "title": "Comparison operators and functions",
    "content": "Use these operators to compare two values as an expression. An expression that uses one of these operators evaluates to a Boolean true or false. You can then combine multiple expressions using the logical operators. == (equality) . Usage: &lt;any type&gt; == &lt;any type&gt; . Binary operator that compares two operands of any type and evaluates to true only if they are exactly the same type and the same value. If the operands are of different types, the result is always false. Examples: . 1 == 1 //true 5 == \"5\" //false \"something\" == \"something\" //true \"Something\" == \"something\" //false [1, -33, 707] == [1, -33] //false [1, 2, 40] == [1, 2, 40] //true [1, 2, 40] == [1, 40, 2] //true [1, -2, 40] == [1, 40] //false [1, 1, 1, 2, 40] == [40, 1, 2] //true [1, 1, 2, 1, 40, 2, 1, 2, 40, 1]== [1, 40, 1, 2] //true true == true //true context.device_properties == {\"os \":\"Windows \", \"version\":11} //true if context.device_properties represents a Windows 11 computer A == A //true even if A is an entity that doesn't exist User::\"alice\" == User::\"bob\" //false -- two different objects of same type User::\"alice\" == Admin::\"alice\" //false -- objects of two different types \"alice\" == User::\"alice //false -- string versus entity . != (inequality) . Usage: &lt;any type&gt; != &lt;any type&gt; . Binary operator that compares two operands of any type and evaluates to true if the operands have different values or are of different types. You can use != only in when and unless clauses. Example: . forbid(principal, action, resource) when{ resource.tag != \"public\" }; . &lt; (long integer ‘less than’) . Usage: &lt;long&gt; &lt; &lt;long&gt; . Binary operator that compares two long integer operands and evaluates to true if the left operand is numerically less than the right operand. Examples: . 3 &lt; 303 //true principal.age &lt; 22 //true (assume principal.age is 21) 3 &lt; \"3\" //type error false &lt; true //type error \"some\" &lt; \"thing\" //type error \"\" &lt; \"zzz\" //type error \"\" &lt; \"\" //type error [1, 2] &lt; [47, 0] //type error .lessThan() (decimal ‘less than’) . Usage: &lt;decimal&gt;.lessThan(&lt;decimal&gt;) . Function that compares two decimal operands and evaluates to true if the left operand is numerically less than the right operand. Examples: . decimal(\"1.23\").lessThan(decimal(\"1.24\")) //true decimal(\"1.23\").lessThan(decimal(\"1.23\")) //false decimal(\"123.45\").lessThan(decimal(\"1.23\")) //false decimal(\"-1.23\").lessThan(decimal(\"1.23\")) //true decimal(\"-1.23\").lessThan(decimal(\"-1.24\")) //false . &lt;= (long integer ‘less than or equal’) . Usage: &lt;long&gt; &lt;= &lt;long&gt; . Binary operator that compares two long integer operands and evaluates to true if the left operand is numerically less than or equal to the right operand. Examples: . 3 &lt;= 303 // true principal.age &lt;= 21 // true (assume principal.age is 21) 3 &lt;= \"3\" // type error false &lt;= true // type error \"some\" &lt;= \"thing\" // type error \"\" &lt;= \"zzz\" // type error \"\" &lt;= \"\" // type error [1, 2] &lt;= [47, 0] // type error .lessThanOrEqual() (decimal ‘less than or equal’) . Usage: &lt;decimal&gt;.lessThanOrEqual(&lt;decimal&gt;) . Function that compares two decimal operands and evaluates to true if the left operand is numerically less than or equal to the right operand. Examples: . decimal(\"1.23\").lessThanOrEqual(decimal(\"1.24\")) // true decimal(\"1.23\").lessThanOrEqual(decimal(\"1.23\")) // true decimal(\"123.45\").lessThanOrEqual(decimal(\"1.23\")) // false decimal(\"-1.23\").lessThanOrEqual(decimal(\"1.23\")) // true decimal(\"-1.23\").lessThanOrEqual(decimal(\"-1.24\")) // false . &gt; (long integer ‘greater than’) . Usage: &lt;long&gt; &gt; &lt;long&gt; . Binary operator that compares two long integer operands and evaluates to true if the left operand is numerically greater than the right operand. Examples: . 3 &gt; 303 // false principal.age &gt; 22 // false (assume principal.age is 21) 3 &lt;= \"3\" // type error false &lt;= true // type error \"some\" &lt;= \"thing\" // type error \"\" &lt;= \"zzz\" // type error \"\" &lt;= \"\" // type error [1, 2] &lt;= [47, 0] // type error .greaterThan() (decimal ‘greater than or equal’) . Usage: &lt;decimal&gt;.greaterThan(&lt;decimal&gt;) . Function that compares two decimal operands and evaluates to true if the left operand is numerically greater than the right operand. Examples: . decimal(\"1.23\").greaterThan(decimal(\"1.24\")) // false decimal(\"1.23\").greaterThan(decimal(\"1.23\")) // false decimal(\"123.45\").greaterThan(decimal(\"1.23\")) // true decimal(\"-1.23\").greaterThan(decimal(\"1.23\")) // false decimal(\"-1.23\").greaterThan(decimal(\"-1.24\")) // true . &gt;= (Long integer ‘greater than or equals’) . Usage: &lt;long&gt; &gt;= &lt;long&gt; . Binary operator that compares two long integer operands and evaluates to true if the left operand is numerically greater than or equal to the right operand. Examples: . 3 &gt;= 303 //false principal.age &gt;= 21 //true (assume principal.age is 21) 3 &gt;= \"3\" //type error false &gt;= true //type error \"some\" &gt;= \"thing\" //type error \"\" &gt;= \"zzz\" //type error \"\" &gt;= \"\" //type error [1, 2] &gt;= [47, 0] //type error .greaterThanOrEqual() (decimal ‘greater than or equal’) . Usage: &lt;decimal&gt;.greaterThanOrEqual(&lt;decimal&gt;) . Function that compares two decimal operands and evaluates to true if the left operand is numerically greater than or equal to the right operand. Examples: . decimal(\"1.23\").greaterThanOrEqual(decimal(\"1.24\")) //false decimal(\"1.23\").greaterThanOrEqual(decimal(\"1.23\")) //true decimal(\"123.45\").greaterThanOrEqual(decimal(\"1.23\")) //true decimal(\"-1.23\").greaterThanOrEqual(decimal(\"1.23\")) //false decimal(\"-1.23\").greaterThanOrEqual(decimal(\"-1.24\")) //true . ",
    "url": "/syntax-operators.html#comparison-operators-and-functions",
    
    "relUrl": "/syntax-operators.html#comparison-operators-and-functions"
  },"83": {
    "doc": "Operators",
    "title": "Logical operators",
    "content": "Use these operators to logically combine Boolean values or expressions. &amp;&amp; (AND) . Usage: &lt;Boolean&gt; &amp;&amp; &lt;Boolean&gt; . Binary operator that evaluates to true only if both arguments are true. In the following policy, the when condition is true if both principal.numberOfLaptops &lt; 5 and principal.jobLevel &gt; 6 are true. permit(principal, action == Action::\"remoteAcces s \", res ource) when { principal.numberO fLaptops &lt; 5 &amp;&amp; principal.jobLevel &gt; 6 } . The &amp;&amp; operator uses short circuit evaluation. If the first argument is false, then the expression immediately evaluates to false and the second argument isn’t evaluated. This approach is useful when the second argument might result in an error if evaluated. You can use the first argument to test that the second argument is a valid expression. The following policy allows only if the principal has the attribute level and the level &gt; 5. permit(principal, action == Action:\"read\", res ource) when { principal has level &amp;&amp; principal.level &gt; 5 }; . The second comparison in this expression is valid only if the numberOfLaptops property for the principal entity has a value. If it doesn’t, the less than operator generates an error. The first expression uses the has operator to ensure that the principal entity does have such a property with a value. If that evaluates to false, then the second expression isn’t evaluated. More Examples: . false &amp;&amp; 3 //false (false &amp;&amp; 3) == 3 //false, short-circuiting true &amp;&amp; 3 //type error 3 &amp;&amp; false // type error . || (OR) . Usage: &lt;Boolean&gt; || &lt;Boolean&gt; . Binary operator that evaluates to true if either one or both arguments are true. This operator uses short circuit evaluation. If the first argument is true, then the expression immediately evaluates to true and the second argument isn’t evaluated. This approach is useful when the second argument might result in an error if evaluated. The first argument should be a test that can determine if the second argument is a valid expression. For example, consider the following expression. It evaluates to true if the principal can’t be confirmed to at least 21 years old and principal is either missing the age property or that property is set to a value less than 21. !(principal has age) || principal.age &lt; 21 . The second comparison in this expression is valid only if the age property for the principal entity is present. If it is missing, the less than operator generates an error. The first expression uses the has operator, inverted by the ! NOT operator, to flag that the principal entity is missing the age property. If that evaluates to true, there is no test of the second expression. The following policy allows if either resource.owner == principal or resource.tag == \"public\" is true. permit(principal, action == Action:\"read\", resource) when { resource.owner == principal || resource.tag == \"public\" } . More Examples: . true || 3 //true, short-circuiting false || 3 //type error 3 || true //type error (true || 3) == 3 //false, short-circuiting (true || 3 || true) == 3 //false, short-circuiting . ! (NOT) . Usage: ` ! ` . Unary operator with only one argument. It inverts the value of the Boolean operand from true to false, or from false to true. Example: . The following policy forbids if the principal does not belong to Group::”family”. forbid(principal, action, resource) when { !(principal in Group::\"family\") }; . You can rewrite the above policy using an unless clause as: . forbid(principal, action, resource) unless { principal in Group::\"family\" }; . More Examples: . ! true // false ! false // true ! 8 // type error if !true then \"hello\" else \"goodbye\" // \"goodbye\" . ",
    "url": "/syntax-operators.html#logical-operators",
    
    "relUrl": "/syntax-operators.html#logical-operators"
  },"84": {
    "doc": "Operators",
    "title": "Arithmetic operators",
    "content": "Use these operators to perform arithmetic operations on long integer values. Notes The arithmetic operators support only values of type Long. They don’t support values of type Decimal. There is no operator for arithmetic division. The arithmetic operators generate errors if they overflow out of the Long integer range from -9223372036854775808 to 9223372036854775807. + (Numeric addition) . Usage: &lt;long&gt; + &lt;long&gt; . Binary operator that adds the two long integer values and returns a long integer sum. Example: . The following policy returns allow if the context budget minus the context downloaded is greater than 100. permit(principal, action, resource) when { context.budget - context.downloaded &gt; 100 }; . Other examples: . 11 + 0 // 11 -1 + 1 // 0 9,223,372,036,854,775,807 + 1 //overflow -9,223,372,036,854,775,808 - 1 + 3 //overflow 7 + \"3\" //type error \"lamp\" + \"la\" //type error - no support for string concatenation . - (Numeric subtraction or negation) . Usage: &lt;long&gt; - &lt;long&gt; . As a binary operator with two operands, it subtracts the second long integer value from the first and returns a long integer difference. Examples: . 44 - 31 // 13 5 - (-3) // 8 -9,223,372,036,854,775,808 - 1 + 3 // overflow . Usage: - &lt;long&gt; . As a unary operator with one operand, it returns the negative of the value. Examples: . -3 . * (Numeric multiplication) . Usage: &lt;long&gt; * &lt;long&gt; . Binary operator that multiplies two long integer values and returns a long integer product. One of the values must be an integer literal, the other value can be an integer literal or an expression that evaluates to an integer value. There is no operator for arithmetic division. Examples: . 10 * 20 // 200 res ource.value * 10 // valid 2 * context.budget &gt; 100 // valid context.budget * context.limit // not valid. One operand must be a constant 9223372036854775807 * 2 // overflow 5 * (-3) // -15 5 * 0 // 0 \"5\" * 0 // type error . ",
    "url": "/syntax-operators.html#arithmetic-operators",
    
    "relUrl": "/syntax-operators.html#arithmetic-operators"
  },"85": {
    "doc": "Operators",
    "title": "Hierarchy and set membership operators and functions",
    "content": "Use these functions to test if entities are members of a hierarchy or a set. in (Hierarchy membership) . Usage: &lt;entity&gt; in &lt;entity&gt; . Boolean operator that evaluates to true if the entity in the left operand is a descendant in the hierarchy under the entity in the right operand. The in operator is transitive. If A is in B, and B is in C, then A is also in C. This approach allows you to model the concept of a multi-tier hierarchy, for example nesting folders in other folders. The in operator is reflexive; If the right operand is a single entity, then the expression evaluates to true if the right entity is the same as the left entity. In other words, an entity is always in its own hierarchy. A is always in A. Usage: &lt;entity&gt; in set(&lt;entity&gt;, &lt;entity&gt;, ...) . Examples: . For example, assume that the principal in a request is User::\"12345\" . principal in User::\"12345\" // true - testing if a value is in itself always returns true principal in [User::\"12345\"] // true - testing if a value is in a set consisting of only itself always returns true principal in Group::\"67890\" // true if User::\"12345\" belongs to Group::\"67890\" principal in [Group::\"67890\"] // true if User::\"12345\" belongs to Group::\"67890\" . More examples: . Consider the following set of entities: . User::\"jane\" in User::\"jane\" // true - `in` is reflexive User::\"bob\" in Group::\"jane_friends\" // true - Group::\"jane_friends\" is an ancestor of User::\"bob\". User::\"john\" in Group::\"jane_friends\" // false - User::\"john\"'s only ancestor is Group\"jane_coworkers\". If the right operand is a set of entities, then the expression is evaluated for each member in the set. For example, consider the following expression. A in [ B, C, D ] . That expression is evaluated as component expressions joined by the logical OR operator, as shown in the following example. A in B || A in C || A in D . If any one or more of the component expressions evaluates to true, then the overall expression evaluates to true. User::\"bob\" in [Group::\"jane_friends\"] // true User::\"alice\" in [ Group::\"jane_family\", Group::\"jane_friends \" ] // true - User::\"Alice\" is a member of Group::\"jane_friends\" User::\"alice\" in [ User::\"bob\", User::\"alice\" ] // true - User::\"alice\" in User::\"alice\" User::\"john\" in [ Group::\"jane_family\", Group::\"jane_friends\" ] // false - User::\"john\" isn't a member of any entities in the set . The right operand of in can be any expression that returns a set of entity references, not just a set literal. For example, suppose the query context contains the following: . { \"groups \": [Group::\"jane_family\", Group::\"jane_friends \"] } . Then the following two expressions in a policy statement are equivalent: . User::\"alice\" in context.groups User::\"alice\" in [Group::\"jane_family\", Group::\"jane_friends\"] . However, the following expression raises a type error because “Team” is a string, not an entity reference. User::\"alice\" in [User::\"alice\", Group::\"jane_friends\", \"Team\"] // type error . Because the in operator is reflexive, A in A returns true even if the entity A does not exist. The evaluator treats entity references that are not in the hierarchy as a valid entity. For example: . Stranger::\"jimmy\" in Stranger::\"jimmy\" // true by reflexivity. Stranger::\"jimmy\" in Group::\"jane_friends\" // false - Stranger::\"jimmy\" does not refer to an existing entity Stranger::\"jimmy\" in [ Group::\"jane_family\", Stranger::\"jimmy\" ] // true - Stranger::\"jimmy\" in Stranger::\"jimmy\" is true . More Examples: . \"some\" in [\"some\", \"thing\"] //type error - these are strings, not entities. For strings, use `contains` for set membership. \"os\" in {\"os\":\"Windows \"} //type error - use `has` operator to check if a key exists . has (presence of attribute test) . Usage: &lt;entity&gt; has &lt;attribute&gt; . Boolean operator that evaluates to true if the left operand has a value defined for the specified attribute. Use this operator to check that a value is present before accessing that value. If you attempt to access a value that isn’t defined, then Cedar generates an error. The following example expression first tests whether the entity A has a defined attribute B. Because the &amp;&amp; operator uses shortcut logic, the second expression is evaluated and the attribute accessed only if the attribute is present. A has B &amp;&amp; A.B == 5 . In the following example, assume that the request has the following context: . \"context\":{ \"role\": [\"admin\", \"us er\"], \"addr\": { \"s treet\": \"main\", \"city\": \"DC\"} \"owner info\": { \"name\": \"Alice\", \"age\": 18 } } . The following condition checks if the context has an attribute role. If the attribute exists, then it checks if it is a set containing the string \"admin\" as an element. context has role &amp;&amp; context.role.contains(\"admin\") //true . The attribute name role can be written as an identifier (as in the previious example) or as a string literal. The following expression is equivalent to the previous one: . context has \"role\" &amp;&amp; context.role.contains(\"admin\") //true . You must check for presence of optional attributes that are nested multiple layers one at a time. For example, to check for the presence of principal.custom.project, you must first check if principal has a custom attribute. You can then check to see if that custom attribute has a project attribute. To do this, you could use the following syntax. principal has custom &amp;&amp; principal.custom has project . If the attribute name is not valid as an identifier, then the string literal syntax must be used for has and attribute values must be accessed with the [] operator instead of using dot syntax. For example, to check if context has an attribute called owner info (with an embedded space), then you could use the following syntax. context has \"owner info\" &amp;&amp; context[\"owner info\"].name == \"Alice\" //true . The following expression returns false because context doesn’t have an attribute tag. context has tag //false . The following expression returns a type error because the left-hand side of the has operator must be an entity or a record. In this example, because role is a set, Cedar generates a type error. context.role has admin //type error . The following expression returns false because the addr sub-record does not have an attribute country. The second expression is not evaluated. context.addr has country &amp;&amp; context.addr.country == \"US \" //false . However, consider the case where context does not have the addr sub-record at all: . \"context\": { \"role\": [\"admin\", \"user\"] } . In that case, then the previous expression that checks for context.addr has country raises a missing-attribute error on context.addr before the has operator is even evaluated, and the entire policy is skipped. If the addr sub-record is optional, you can avoid this error by checking whether addr is present before accessing it with the . operator: . context has addr &amp;&amp; context.addr has country &amp;&amp; context.addr.country == \"US\" // false, with no error .contains() (single element set membership test) . Usage: &lt;set&gt;.contains(&lt;entity&gt;) . Function that evaluates to true if the operand is a member of the receiver on the left side of the function. The receiver must be of type set. Examples: . [1,2,3].contains (1) // true [1,\"something\",2].contains(1) // true [1,\"something\",2].contains(\"Something\") // false - string comparision is case-sensitive [\"some\", \"useful\", \"tags\"].contains(\"useful\") // true [].contains (100) // false context.role.contains (\"admin\") // true if the set `role` contains the string \"admin\" [User::\"alice\"].contains (principal) // true if principal == User::\"alice\" \"ham and ham\".contains (\"ham\") // type error - 'contains' is not allowed on strings .containsAll() (all element set membership test) . Usage: &lt;set&gt;.containsAll(&lt;set&gt;) . Function that evaluates to true if every member of the operand set is a member of the receiver set. Both the receiver and the operand must be of type set. [1, -22, 34].containsAll([-22, 1]) // true [1, -22, 34].containsAll([-22]) // true [43, 34].containsAll([34, 43]) // true [1, -2, 34].containsall([1, -22]) // false [1, 34].containsAll [1, 101, 34] // false [false, 3, [47, 0], \"some\"].containsAll([3, \"some\"]) // true [false, 3, [47, 0], {\"2\": \"ham\"}].containsAll([3, {\"2\": \"ham\"}]) // true [2, 43].containsAll([]) // true [].containsAll([2, 43]) // false [false, 3, [47, 0], \"thing\"].containsAll(\"thing\") // type error - operand a string \"ham and eggs\".containsAll(\"ham\") // type error - prefix and operand are strings {\"2\": \"ham\", \"3\": \"eggs \"}.containsAll({\"2\": \"ham\"}) // type error - prefix and operand are records .containsAny() (any element set membership test) . Usage: &lt;set&gt;.containsAny(&lt;set&gt;) . Function that evaluates to true if any one or more members of the operand set is a member of the receiver set. Both the receiver and the operand must be of type set. [1, -22, 34].containsAny([1, -22]) // true [1, -22].containsAny([1, -22, 34]) // true [-22].containsAny([1, -22, 34]) // true [1, 101].containsAny([1, -22, 34]) // true [1, 101].containsAny([-22, 34]) // false [\"alice\",\"bob\",\"charlie\"].containsAny([\"david\",\"bob\",\"juan\"]) // true [].containsAny([\"bob\"]) // false [\"bob\"].containsAny([]) // false \"ham\".containsAny(\"ham and eggs\") // type error - operand is a string {\"2\": \"ham\"}.containsAny({\"2\": \"ham\", \"3\": \"eggs \"}) // type error - prefix and operands are records . ",
    "url": "/syntax-operators.html#hierarchy-and-set-membership-operators-and-functions",
    
    "relUrl": "/syntax-operators.html#hierarchy-and-set-membership-operators-and-functions"
  },"86": {
    "doc": "Operators",
    "title": "IP address functions",
    "content": "Use these functions to test characteristics of IP addresses and ranges.isIpv4() (IPv4 address valid test) . Usage: &lt;ipaddr&gt;.isIpv4() . Evaluates to true if the receiver is an IPv4 address. This function takes no operand. ip(\"127.0.0.1\").isIpV4() //true ip(\"::1\").isIpV4() //false ip(\"127.0.0.1/24\").isIpV4() //true .isIpv6() (IPv6 address valid test) . Usage: &lt;ipaddr&gt;.isIpv6() . Function that evaluates to true if the receiver is an IPv6 address. This function takes no operand. ip(\"127.0.0.1/24\").isIpV6() //false ip(\"ffee::/64\").isIpV6() //true ip(\"::1\").isIpV6() //true .isLoopback() (test for IP loopback address) . Usage: &lt;ipaddr&gt;.isLoopback() . Function that evaluates to true if the receiver is a valid loopback address for its IP version type. This function takes no operand. ip(\"127.0.0.2\").isLoopback() //true ip(\"::1\").isLoopback() //true ip(\"::2\").isLoopback() //false .isMulticast() (test for multicast address) . Usage: &lt;ipaddr&gt;.isMulticast() . Function that evaluates to true if the receiver is a multicast address for its IP version type. This function takes no operand. ip(\"127.0.0.1\").isMulticast() //false ip(\"ff00::2\").isMulticast() //true .isInRange() (test for inclusion in IP address range) . Usage: &lt;ipaddr&gt;.isInRange(&lt;ipaddr&gt;) . Function that evaluates to true if the receiver is an IP address or a range of addresses that fall completely within the range specified by the operand. ip(\"192.168.0.1\").isInRange(ip(\"192.168.0.1/24\")) //true ip(\"192.168.0.1\").isInRange(ip(\"192.168.0.1/28\")) //true ip(\"192.168.0.75\").isInRange(ip(\"192.168.0.1/24\")) //true ip(\"192.168.0.75\").isInRange(ip(\"192.168.0.1/28\")) //false ip(\"1:2:3:4::/48\").isInRange(ip(\"1:2:3:4::\")) //true ip(\"192.168.0.1\").isInRange(ip(\"1:2:3:4::\")) //false . ",
    "url": "/syntax-operators.html#ip-address-functions",
    
    "relUrl": "/syntax-operators.html#ip-address-functions"
  },"87": {
    "doc": "Operators",
    "title": "Operators",
    "content": " ",
    "url": "/syntax-operators.html",
    
    "relUrl": "/syntax-operators.html"
  },"88": {
    "doc": "Basic syntax",
    "title": "Basic policy construction in Cedar",
    "content": "A policy is a text document that includes the following elements: . | Effect – The effect specifies the intent of the policy, to either permit` or forbid any request that matches the scope and conditions specified in the policy. | Scope – The scope specifies the combination of principals, actions, and resources to which the policy applies. Inclusion of these elements is mandatory. A policy that has only a scope without additional context conditions can be part of a role-based access control strategy. | Conditions – (Optional) You can optionally provide additional conditions. These conditions must be satisfied for the policy to affect the evaluation of the authorization request. These conditions are expressed as when and unless clauses. You can use the conditions to evaluate the attributes of the principals, resources, and other elements that make up the context of the request. A policy that includes conditions can be part of an attribute-based access control strategy. | Annotations – (Optional) An annotation is an arbitrary string value that can be used by other services that read and process Cedar policies. An annotation has no impact on policy evaluation. | . The policy must end with a semicolon character (;). When the request exactly matches the scope, and all of the context conditions evaluate to true, then that policy evaluates to true. This process repeats for all policies that are relevant to the principal and resources referenced by the request. This guide includes examples that use simple entity identifiers, such as jane or bob for the name of an entity of type User. This is done to make the examples more readable. However, in a production system it is critical for security reasons that you use unique values that can’t be reused. We recommend that you use values like universally unique identifiers (UUIDs). For example, if user jane leaves the company, and you later let someone else use the name jane, then that new user automatically gets access to everything granted by policies that still reference User::\"jane\". Cedar can’t distinguish between the new user and the old. This applies to both principal and resource identifiers. Always use identifiers that are guaranteed unique and never reused to ensure that you don’t unintentionally grant access because of the presence of an old identifier in a policy. Where you use a UUID for an entity, we recommend that you follow it with the // comment specifier and the ‘friendly’ name of your entity. This helps to make your policies easier to understand. For example: . principal == User::\"a1b2c3d4-e5f6-a1b2-c3d4-EXAMPLE11111\", // alice . ",
    "url": "/syntax-policy.html#basic-policy-construction-in-cedar",
    
    "relUrl": "/syntax-policy.html#basic-policy-construction-in-cedar"
  },"89": {
    "doc": "Basic syntax",
    "title": "Effect",
    "content": "The effect of the policy specifies whether Cedar should permit or forbid requests that evaluate as a match for the policy. The effect element can have one of the following values: . | permit – If all elements in the policy match, then the policy results in an Allow. | forbid – If all elements in the policy match, then the policy results in a Deny. | . After all policies in the policy store are evaluated, the results are combined as follows: . | If at least one matching policy results in Allow and there are exactly zero policies that result in Deny, then the overall result of the evaluation is Allow. | If at least one matching policy results in Deny or if there are exactly zero policies that result in Allow, then the overall result of the evaluation is Deny. | . The following are two key principles to remember that embody the previous two rules: . | The default result, exemplified by an empty set of policies, is a Deny for the request, because there isn’t at least one policy that results in Allow. This is referred to as an implicit deny. | A Deny result for any policy evaluation results in an overall Deny for the request. This is referred to as an explicit deny. Important An explicit Deny for any one policy **always **overrides any Allow from other policies. | . Effect examples . permit . The following permit example policy allows Alice to view a specific photo. permit( principal == User::\"alice\", action == Action::\"view\", resource == Photo::\"VacationPhoto94.jpg\" ); . forbid . The following forbid example policy denies any action by any user except the resource’s owner on any resource that has the private attribute set to true, unless the principal making the request is the resource owner. This policy doesn’t explicitly allow anything; it only forbids when it matches. A resource owner making a request on a private resource must still have a separate policy that explicitly allows the action on the specified resource. forbid ( principal, action, resource ) when { resource.private } unless { principal == resource.owner }; . ",
    "url": "/syntax-policy.html#effect",
    
    "relUrl": "/syntax-policy.html#effect"
  },"90": {
    "doc": "Basic syntax",
    "title": "Scope",
    "content": "A request always includes information that Cedar uses to answer the following three questions: . | Principal –Who is making the request? | Action – What operation does the principal want to perform? | Resource – What does the principal want to perform the action on? | . The scope section of a Cedar policy statement defines which values match the request. principal . The principal element in a Cedar policy represents a role, user, service, or other identity that can make a request to perform an action on a resource in your application. If the principal making the request matches the principal defined in this policy statement, then this element matches. The principal element must be present. If you specify only principal without an expression that constrains its scope, then the policy applies to any principal. Examples of the principal element . //matches any principal entity of any type principal //matches only the one specified entity of type User principal == User::\"alice\" //matches any principal in the hierarchy of the specified Group principal in Group::\"alice_friends\" . action . The action element in a Cedar policy is a list of the operations in your application for which this policy statement controls access. If the operation in the request matches one of the action items defined in this policy statement, then this element matches. Examples of the action element . //matches any action action //matches only the one specified action action == Action::\"view\" //matches any of the listed actions action in [Action::\"listAlbums\", Action::\"listPhotos\", Action::\"view\"] //matches any action in the hierarchy of the admin entity of type PhotoFlashRole action in PhotoFlashRole::\"admin\" . resource . The resource element in a Cedar policy is a resource defined by your application that can be accessed or modified by the specified action. The resource element must be present. If you specify only resource without an expression that constrains its scope, then the policy applies to any resource. The principal, action, and resource elements are defined as entities. Examples of the resource element . //matches any resource resource //matches only the one specified resource of type Photo resource == Photo::\"VacationPhoto94.jpg\" //matches any resource that is in the hierarchy of the specified entity of type Album resource in Album::\"alice_vacation\" . ",
    "url": "/syntax-policy.html#scope",
    
    "relUrl": "/syntax-policy.html#scope"
  },"91": {
    "doc": "Basic syntax",
    "title": "Conditions",
    "content": "Conditions specify any additional constraints that Cedar must consider when deciding to allow or deny the request. Every when condition must evaluate to true and every unless condition must evaluate to false for the policy to match and contribute to the final decision. The conditions evaluate details that are unique to a particular access request. Consider a web service that accepts HTTP requests. The conditions for such a request might include things like the IP address from which the request originates, the HTTP headers in the request, the time of day that the request was sent, the user’s authentication posture, or detailed information about the query parameters in the HTTP request. Conditions can also evaluate attributes of the principals and resources specified in the query. For example, a policy could contain a condition that specifies that principals can edit any photo that has an owner attribute with a value that matches the ID of the principal making the request. permit( principal, action == Action::\"editPhoto\", resource ) when { resource.owner == principal }; . The scope values of principal, action, and resource represent stable information in the system and must be present in every request. In comparison, context represents information about a point-in-time request and is required only for relevant request scenarios. Context elements take the following two forms: . | when | unless | . when . The when clause causes the policy to match the request only if the embedded expression evaluates to true. Examples of the when clause . The following when example matches the request if the principal making the request is a member of the HardwareEngineering department and has a jobLevel of at least 5. If either attribute is missing from the principal making the request, then the policy doesn’t match. when { principal.department == \"HardwareEngineering\" &amp;&amp; principal.jobLevel &gt;= 5 } . The following when example matches the request if the request was submitted before the specified date and time. when { context.time.now &lt; timestamp(\"2022-01-01T10:15:00.021-05:00\") } . unless . The unless clause causes the policy to match the request only if the embedded expression evaluates to false. Examples of the unless clause . The following unless clause does not match the request if the principal making the request is the resource’s owner. unless { principal == resource.owner } . The following policy example denies any request if the calling principal isn’t authenticated with multi-factor authentication (MFA). The policy assumes that usedMFA evaluates as a boolean to true or false. forbid ( principal, action, resource ) unless { context.authentication.usedMFA }; . ",
    "url": "/syntax-policy.html#conditions",
    
    "relUrl": "/syntax-policy.html#conditions"
  },"92": {
    "doc": "Basic syntax",
    "title": "Annotations",
    "content": "You can attach arbitrary string values to Cedar policies in the form of annotation. An annotation has no impact on policy evaluation. Annotations are stored as part of the policy and are available for use by services that read and process Cedar policies. You can place annotations only at the very top of the policy before the effect element. An annotation takes the form of the following string: . @annotationname(\"annotation value\") . The following example shows two annotations that could be part of a policy. @advice(\"My advice\") @id(\"My ID\") permit( ... ); . ",
    "url": "/syntax-policy.html#annotations",
    
    "relUrl": "/syntax-policy.html#annotations"
  },"93": {
    "doc": "Basic syntax",
    "title": "Basic syntax",
    "content": " ",
    "url": "/syntax-policy.html",
    
    "relUrl": "/syntax-policy.html"
  },"94": {
    "doc": "Policy syntax",
    "title": "Syntax of the Cedar policy language",
    "content": "The topics in this section describe the syntax of the Cedar policy language. ",
    "url": "/syntax.html#syntax-of-the-cedar-policy-language",
    
    "relUrl": "/syntax.html#syntax-of-the-cedar-policy-language"
  },"95": {
    "doc": "Policy syntax",
    "title": "Policy syntax",
    "content": " ",
    "url": "/syntax.html",
    
    "relUrl": "/syntax.html"
  },"96": {
    "doc": "Policy templates",
    "title": "Cedar policy templates",
    "content": "A policy template is a policy that contains placeholders. The placeholders can represent the principal and the resource. Later, you can create a template-linked policy based on the policy template by specifying the exact principal and resource to use for this one policy. Template-linked policies are dynamic, meaning that the new policy stays linked to its policy template. When you change a policy statement in the policy template, any policies linked to that template automatically and immediately use the new statement for all authorization decisions made from that moment forward. You can use placeholders in a Cedar policy template for only the following two elements of a policy statement: . | Principal – ?principal | Resource – ?resource | . You can use either one or both in a policy template. Placeholders can appear in only the policy head on the right-hand side of the == or in operators. Then, when you create a policy based on the policy template, you must specify values for each of the placeholders. Those values are combined with the rest of the policy template to form a complete and usable template-linked policy. As an example, consider the scenario where a common action is to grant certain groups with the ability to view and comment on any photos that are not marked as private. You decide to associate the action with a Share button in your application’s interface. You could create a template that looks like the following example. permit( principal in ?principal, action in [Action::\"view\", Action::\"comment\"], resource in ?resource ) unless { resource.tag ==\"private\" }; . When a user chooses Share, your application instantiates that policy template into an individual template-linked policy. The template-linked policy references the policy template and specifies values for the placeholders. For example, a user chooses to share their vacationTrip album with their friendsAndFamilies group. Choosing Share in your application starts the creation of a template-linked policy that specifies UserGroup::\"friendsAndFamily\" as the principal and Album::\"vacationTrip\" as the resource. This template-linked policy behaves exactly as if it were written like the following static policy. permit( principal in UserGroup::\"friendsAndFamily\", action in [Action::\"view\", Action::\"comment\"], resource in Album::\"vacationTrip\" ) unless { resource.tag ==\"private\" }; . However, the new policy isn’t actually constructed as a static policy with that policy statement. Instead, the new policy is a template-linked policy that dynamically links the policy template with those two specific placeholder values. Later, you might choose to modify the policy template, such as by adding an additional condition to the unless clause. From that moment on the change immediately affects all authorization decision results for all template-linked policies created from the modified policy template. ",
    "url": "/templates.html#cedar-policy-templates",
    
    "relUrl": "/templates.html#cedar-policy-templates"
  },"97": {
    "doc": "Policy templates",
    "title": "Policy templates",
    "content": " ",
    "url": "/templates.html",
    
    "relUrl": "/templates.html"
  },"98": {
    "doc": "Terms & concepts",
    "title": "Cedar terms and concepts",
    "content": "Cedar manages fine-grained permissions to support the authorization requirements for custom applications. To create Cedar policies successfully, you should understand the following concepts. Topics on this page . | Authorization | Policy | Policy evaluation | Policy template | Entity | Namespaces | Groups and hierarchies | Schema | . ",
    "url": "/terminology.html#cedar-terms-and-concepts",
    
    "relUrl": "/terminology.html#cedar-terms-and-concepts"
  },"99": {
    "doc": "Terms & concepts",
    "title": "Authorization",
    "content": "Authorization is the process of determining if a specific user request to do something is allowed by the defined set of policies. Authorization works by evaluating each incoming request against the set of policies provided to Cedar. Authorization is preceded by authentication. Authentication is the process of verifying the principal’s identity, meaning that they are really who they claim to be. Authentication can involve user names, passwords, multi-factor authentication (MFA) devices, or other means of proving identity. Once authenticated, a user or device becomes a principal that can make a request. Cedar lets you describe permissions by creating policies as text documents that describe which principals are allowed to perform which actions, on which resources, and in a specific context. When a principal attempts to do something in an application, the application generates an authorization request. Cedar evaluates requests against the set of defined policies, producing a decision to allow or deny the request. ",
    "url": "/terminology.html#authorization",
    
    "relUrl": "/terminology.html#authorization"
  },"100": {
    "doc": "Terms & concepts",
    "title": "Policy",
    "content": "A policy is a statement that declares which principals are explicitly permitted, or explicitly forbidden, to perform an action on a resource. The collection of policies together define the authorization rules for your application. A policy begins by specifying the effect, to either permit or forbid any requests that match the scope and conditions specified in the policy. The scope identifies the specific principal and resource to which the policy applies, and the actions that the principal can perform on the resource. The scope is mandatory. Optionally, you can specify conditions that must be true for the policy to affect the request. These conditions take the form of when and unless clauses that evaluate the attributes of the principals, resources, and other elements that make up the context of the request. Conditions can check things like the value of tags attached to the principal and resource, the time of day the request is made, or the IP address from which the request is sent. In Cedar, you can create a policy in one of two ways: . | Static policies – Standalone, complete policies that require no additional processing and are ready to be used in authorization decisions by Cedar. For more information about creating a static policy, see Basic policy construction. | Template-linked policies – Policies created from a policy template. This policy type consists of a template that has placeholders for the principal, resource, or both. The template is completed by replacing the placeholders with specific values. This completed template results in a template-linked policy that can be evaluated at runtime like a static policy. | . You can use a variety of strategies to construct the policies. Some of the common strategies are the following: . | Role-based access control (RBAC) – Cedar lets you define roles that receive a set of permissions granted by associating policies with the role. These roles can then be assigned to one or more identities. Each assigned identity acquires the permissions granted by the policies associated with the role. If the policies associated with a role are modified, it automatically impacts any identity assigned to that role. Cedar supports RBAC decisions by using groups for your principals. | Attribute-based access control (ABAC) – Cedar uses the attributes attached to the principal and the resource to determine the permissions. For example, a policy can state that all users that are tagged as the owner of a resource automatically have access. A different policy could state that only users that are members of the Human Resources (HR) department can access resources that are tagged as HR resources. | . ",
    "url": "/terminology.html#policy",
    
    "relUrl": "/terminology.html#policy"
  },"101": {
    "doc": "Terms & concepts",
    "title": "Policy evaluation",
    "content": "An authorization request is a request by an application for an authorization decision, asking the question “Can this principal take this action on this resource in this context?”. To reach the decision, Cedar’s authorization engine evaluates a request against each policy, and combines the results. It ultimately produces an authorization response that consists of the decision (Allow or Deny), and the list of determining policies that are the reasons for that decision. Your application must gather all of the relevant information and provide it to Cedar’s authorization engine when making the request. | All of the details about the principal and resource entities must be provided to Cedar. These details must include all of the entity data that are relevant to the request. For example, for a request to authorize a user named Juan to access a shared photo, the request must include the entities for the groups that Juan is a member of, the folder hierarchy where the photo resides, and any other relevant attributes of the user and photo. | Other details that might be useful to the decision, including the transient or session-specific details, such as the IP address of the requesting computer and the list of valid IP ranges that make up the company’s internal network, or whether the user authenticated using a multi-factor authentication (MFA) device. This additional information is called the context. | All of the policies that match any one or more of the principal, actions, and the resource specified in the request. We recommend that you include all policies to avoid the risk of missing a relevant policy. | . The algorithmic details for how authorization decisions are made, and how individual policies are evaluated, are discussed in the authorization section of these docs. ",
    "url": "/terminology.html#policy-evaluation",
    
    "relUrl": "/terminology.html#policy-evaluation"
  },"102": {
    "doc": "Terms & concepts",
    "title": "Policy template",
    "content": "A policy template is a policy that has a placeholder for either the principal, the resource, or both. A policy template is useful when you have a common pattern for access that you need to apply to many resources, or many principals. You can’t use a template in an authorization decision directly. Instead, you first associate a principal and resource with the template to create a template-linked policy that is complete and usable for authorization decisions. For example, a policy template might allow commenting on any photo in an album unless that photo is tagged “Private”. Instead of having to manually duplicate such a policy statement in a policy for every user who accesses the album, you can create a policy template. A policy created from a policy template is called a template-linked policy. When you create a template-linked policy, you associate the policy template with the principal who needs access to the resource. Template-linked policies are dynamic. When you change the policy statement in a policy template, all policies created from that policy template use the new policy statement automatically in all authorization decisions from that moment on. This capability is useful when you need to apply the same permissions to many principal and resource pairs. For more information about creating and using policy templates, see Cedar policy templates. ",
    "url": "/terminology.html#policy-template",
    
    "relUrl": "/terminology.html#policy-template"
  },"103": {
    "doc": "Terms & concepts",
    "title": "Entity",
    "content": "A principal, an action, or a resource that is part of your application are all represented in Cedar as entities. Entities are referenced by their type and identifier, together called the entity’s unique identifier (UID). In the example policies P1 and P2 above, User::\"jane\", Action::\"ViewPhoto\", and UserGroup::\"kevinFriends\" are all UIDs. Here, User, UserGroup, and Action are entity types, and \"jane\", \"kevinFriends\", and \"viewPhoto\" are entity identifiers. The Action entity type is specially reserved for use with actions, but otherwise you can define whatever entity types are required by your application scenario. Entities have attributes that describe the entity in some way. For example, an entity of type Photo might contain attributes like the following: . | A name (a string) | A createdDate (a string containing a date) | A location (a set of type Decimal that represent coordinates) | The photographer (a reference to another entity representing the user who took the photo). | . Define the attributes that are useful to your scenario. For more details about entities, see Entity in Cedar syntax - elements of the policy language. ",
    "url": "/terminology.html#entity",
    
    "relUrl": "/terminology.html#entity"
  },"104": {
    "doc": "Terms & concepts",
    "title": "Namespaces",
    "content": "As software products increase in size and organizations grow, multiple services can be added to contribute to the overall implementation of an application or product portfolio. You can see this outcome happening when vendors offer several products to customers, or alternatively, in service meshes where multiple services contribute portions of an application. When this situation occurs, Cedar entity definitions can become ambiguous. For example, consider a vendor that offers both a hosted database product and a hosted furniture design service. In this environment, a Cedar action entity such as Action::\"createTable\" is ambiguous; it could be about creating a database table or a new piece of furniture. Similarly, an entity UID such as Table::\"0d6169ca-b246-43a7-94b9-8a68a9e8f8b3\" could refer to either product. This ambiguity can become an issue in circumstances such as the following: . | When both services store their Cedar policies in a single policy store. | If policies are later aggregated into a central repository to explore cross-cutting questions about a customer’s access permissions throughout the portfolio of services. | . To resolve this ambiguity, you can add namespaces to Cedar entities, including actions. A namespace is a string prefix for a type, separated by a pair of colons (::) as a delimiter. Database::Action::\"createTable\" Database::Table::\"c7b981f1-97e4-436b-9af9-21054a3b30f1\" Furniture::Action::\"createTable\" Furniture::Table::\"c7b981f1-97e4-436b-9af9-21054a3b30f1\" . Namespaces can also be nested to arbitrary depth. ExampleCo::Database::Table::\"c7b981f1-97e4-436b-9af9-21054a3b30f1\" ExampleCo::Furniture::Table::\"c7b981f1-97e4-436b-9af9-21054a3b30f1\" ExampleCo::This::Is::A::Long::Name::For::Something::\"12345\" . ",
    "url": "/terminology.html#namespaces",
    
    "relUrl": "/terminology.html#namespaces"
  },"105": {
    "doc": "Terms & concepts",
    "title": "Groups and hierarchies",
    "content": "You can represent a group in Cedar by adding a parent attribute to an entity. All entities with the same parent can be considered members of that group. If you have an entity “A” that has a parent entity “B”, then you can say that A is a member of B. Because a group can include other groups as members, you can use groups to model a multi-tiered hierarchy. You’re not limited to the generic concept of a group with a single collection of members. In addition to the expected User as a member of a UserGroup for principals, you can also apply this approach to your resource types. For example, you can mimic the File in a Folder paradigm, with folders nested in other folders. You can also group actions, where an action like ViewPhoto can be classified as a member of the ReadOnly actions collection. You can use the in operator in a policy condition to check whether one entity has another entity in its hierarchy. For example, the following policy snippet uses the in operator twice to allow any user who is a member of Group::\"janeFriends\" to view any photo that is part of Album::\"janeTrips\". permit( principal in Group::\"janeFriends\", action == Action::\"ViewPhoto\", resource in Album::\"janeTrips\" ); . ",
    "url": "/terminology.html#groups-and-hierarchies",
    
    "relUrl": "/terminology.html#groups-and-hierarchies"
  },"106": {
    "doc": "Terms & concepts",
    "title": "Schema",
    "content": "A schema is a declaration of the structure of the entity types supported by your application, and the actions your application may provide in authorization requests. Cedar uses JSON to define a schema. You can use the schema to define the principals, resources, and actions used by your application. Each definition specifies the structure of the entity that your application recognizes. For example, a resource of type Photo could be defined to include both a Name attribute that is a string, and a LocationTaken attribute that is a record. That record could include Latitude and Longitude values that are both decimal. Cedar can use the schema to validate your authorization policies. Validation helps ensure that you don’t create a policy that references an entity or attribute one way, and then reference that entity or attribute in a different way when you make authorization requests later. Validation also ensures that you use the right data types. For example, if the Age attribute is defined in your schema as type Long, then the following line in a policy submitted to Cedar for validation generates an error. unless { principal.Age &gt; \"21\" } . Cedar determines from the schema that the Age attribute is type Long, and that digits with quotes around them are always of type String. This line fails validation because the &gt; comparison operator works only with Long values and can’t compare with a String. If you remove the quotes from around the 21 and resubmit the policy, Cedar successfully validates the policy. Cedar doesn’t require you to define a schema. However, if you don’t define a schema, then Cedar doesn’t have a way to ensure that the policies adhere to your intentions. If the structure or type of the entity or attribute inferred by a policy doesn’t match the structure or type of the entity or attribute inferred by the parameters of an authorization request, then Cedar can generate errors or return incorrect authorization results. Because of this possibility, we recommend that you create schemas for your applications. When you submit policies to Cedar, your policies are evaluated by default using Strict mode. You can optionally turn validation off. For details about the syntax required to define a schema, see Cedar schema format. ",
    "url": "/terminology.html#schema",
    
    "relUrl": "/terminology.html#schema"
  },"107": {
    "doc": "Terms & concepts",
    "title": "Terms & concepts",
    "content": " ",
    "url": "/terminology.html",
    
    "relUrl": "/terminology.html"
  },"108": {
    "doc": "Policy validation",
    "title": "Cedar policy validation against schema",
    "content": "Cedar policies are code, and as with all code it is possible to make mistakes that mean the code will not behave as expected. For example, the following is a well-formed Cedar policy according to syntax rules, but with a number of typos and type errors. permit ( principal == ExampleCo::Uzer::\"12345\", // should be \"User\", not \"Uzer\" action == ExampleCo::Action::\"ReadFile\", // should be \"readFile\", not \"ReadFile\" resource == ExampleCo::User::\"67890\" // \"readFile\" isn't a valid operation on a User ) when { principal.isAcctive // should be \"isActive\", not \"isAcctive\" &amp;&amp; principal.username &gt; 2 // comparing a string against a number }; . Cedar can’t know whether this policy is right or wrong by examining it in isolation. For example, Cedar does not know if the policy author meant Uzer or User because both are well-formed names. If the policy were subsequently evaluated during an authorization decision, it either would not match at all due to the mistakes in the policy scope (e.g., if there are no entities of type Uzer then the first comparison would always be false), or if the scope’s errors were corrected the evaluator would return diagnostics about accessing undefined attributes and performing invalid comparisons of strings and integers. Ultimately, the policy will have no impact: policies that always evaluate to false or exhibit errors during evaluation are ignored. If no policy grants access, Cedar returns a default decision of DENY. However, it can be frustrating when a policy isn’t behaving as expected. To avoid this frustration, it is better to learn that a policy is invalid when you’re creating it, so mistakes can be fixed before they have an impact on your application’s operation. This capability is provided by Cedar validation. To validate a policy, Cedar needs information about the application. It needs to know the correct names of entity types, the attributes they possess, and the allowed parent/child relationships. It also needs to know which actions are allowed, and the expected types of the principal, resource, and context components that are part of requests made with this action. All of this information is provided to Cedar by defining a schema. This topic provides a brief overview of schemas and how they work to provide validation. For a full description of the schema format with a sample schema, see Cedar schema format. Topics on this page . | Example of schema-based validation | Supported validation checks | Enforcement of validation rules: Expectations | Benefits of validation and schemas | . ",
    "url": "/validation.html#cedar-policy-validation-against-schema",
    
    "relUrl": "/validation.html#cedar-policy-validation-against-schema"
  },"109": {
    "doc": "Policy validation",
    "title": "Example of schema-based validation",
    "content": "The following is an example of a basic Cedar schema. { \"ExampleCo::Personnel\": { \"entityTypes\": { \"Employee\": { \"shape\": { \"type\": \"Record\", \"attributes\": { \"name\": { \"type\": \"String\" }, \"jobLevel\": { \"type\": \"Long\" }, \"numberOfLaptops\": { \"type\": \"Long\", \"required\": false } } } } }, \"actions\": { \"remoteAccess\": { \"appliesTo\": { \"principalTypes\": [\"Employee\"] } } } } } . This schema specifies the following: . | The entities defined in this schema exist in the namespace ExampleCo::Personnel. References to those entities within policies require the namespace prefix, e.g., ExampleCo::Personnel::Employee. References to those entities within the schema, within the namespace declaration, need no namespace prefix, e.g., we write just Employee in the principalTypes part, rather than ExampleCo::Personnel::Employee. | Every entity of type Employee in the store has an attribute name with a value that is a Cedar String, an attribute jobLevel with a value that is a Cedar Long, and an optional attribute numberOfLaptops that is also a Cedar Long. | Any authorization request from the application that specifies action Action::\"remoteAccess\" is expected to specify only principals that are of type Employee (with no restriction on the type of a request’s resource). | . Consider the following policy. permit ( principal, action == ExampleCo::Personnel::Action::\"remoteAccess\", resource ) when { principal.numberOfLatpops &lt; 5 &amp;&amp; // (1) principal.name &gt; 3 &amp;&amp; // (2) principal.jobLevel == \"somethingelse\" // (3) }; . The Cedar validator knows that any request that triggers evaluation of this policy must have action Action::\"remoteAccess\". According to our example schema, such a request must have a principal of type Employee (the resource can be anything, or unspecified). With this knowledge, validation will report an error or warning on each of the comparisons 1 through 3 in the when clause for the following reasons: . | Validation error – The policy tries to access an attribute that isn’t defined for Employee types. In this case, the error is because of a typo (numberOfLatpops instead of numberOfLaptops). | Validation error – The left operand of &gt; is of type String. However, &gt; only accepts operands of type Long, so this policy always raises a runtime error. | Validation error – The left operand of == is always of type Long and the right operand is always a String. Because the == operator always returns false if its operands have different runtime types, this comparison always returns false. Although this comparison won’t raise a runtime error during evaluation, it probably isn’t what the policy author intended and so is flagged as a validation error. | . ",
    "url": "/validation.html#example-of-schema-based-validation",
    
    "relUrl": "/validation.html#example-of-schema-based-validation"
  },"110": {
    "doc": "Policy validation",
    "title": "Supported validation checks",
    "content": "The validator compares a policy with a schema to look for inconsistencies. From these inconsistencies, the validator detects the following errors: . | Unrecognized entity types – For example, misspelling File as Filee. | Unrecognized actions – For example, misspelling Action::\"viewFile\" as Action::\"viewFiel\". | Action applied to unsupported principal or resource – For example, saying a File can View a User. | Improper use of in or == – For example, stating principal in Folder::\"folder-name\" when a principal can’t be a File. | Unrecognized attributes – For example, principal.jobbLevel has a typo and should be jobLevel. | Unsafe access to optional attributes – For example, principal.numberOfLaptops where numberOfLaptops is an optional attribute declared with \"required\": false. Such tests should be guarded by including a has check as the left side of the shortcut &amp;&amp; expression. For example, as in principal has numberOfLaptops &amp;&amp; principal.numberOfLaptops &gt; 1. | Type mismatch in operators – For example, principal.jobLevel &gt; \"14\" is an illegal comparison with a String. | Cases that always evaluate to false, and thus never apply – For example, when { principal has manager &amp;&amp; principal.manager == User::\"Ethel\" } always evaluates to false when the type of principal will never have the manager attribute, as made clear in the schema, so the policy can never apply. | . The schema can also specify the expected format of the context record for each Action. Making this specification lets Cedar also flag errors on references to context. ",
    "url": "/validation.html#supported-validation-checks",
    
    "relUrl": "/validation.html#supported-validation-checks"
  },"111": {
    "doc": "Policy validation",
    "title": "Enforcement of validation rules: Expectations",
    "content": "As implied by the discussion above, we expect validation to be performed before a policy is used by the authorization engine to decide authorization requests. Indeed, the Cedar authorization APIs do not perform validation at the same time that a request is evaluated. Rather, validation is an entirely separate API which can be invoked when policies are loaded or created. We expect that all authorization requests adhere to the rules given in the schema used to validate the policies. In particular: . | For a request with components PARC (principal, action, resource, context), the A component must be an action enumerated in the actions part of the schema, and the PRC components will have the types given with A in the schema. Our example schema above states that A must always be ExampleCo::Personnel::Action::\"remoteAccess\" (since it’s the only action given in the schema), and for this action P must be an entity of type ExampleCo::Personnel::Employee, R can be any entity (or omitted entirely), and C must be the empty record {} (since no information about the context is given). | The entities used when evaluating the request must have the structure given in the entityTypes part of the schema. Our example schema above states that ExampleCo::Personnel::Employee entities have at least two attributes (name and jobLevel) and optionally have a third (numberOfLaptops), each with the types given (String, Long, and Long, respectively). Schemas may also specify the expected hierarchical relationships among entities (not shown in the example). | . If these expectations are not met then a policy that the validator accepts as valid may fail with an error when evaluated, causing it to be ignored. To see why, consider the following policy, which passes validation when using our example schema. permit(principal, action, resource) when { principal.name == \"superuser\" || principal.jobLevel &gt; 8 }; . This policy states that any principal whose name is \"superuser\" or whose jobLevel is greater than 8 can perform any action on any resource. According to our example schema, all principals are expected to have type Employee, which is the only principal type given for the sole action listed. Now suppose we submitted the following authorization request: . | P = ExampleCo::Personnel::Employee::\"Rick\" | A = ExampleCo::Personnel::Action::\"remoteAccess\" | R = omitted | C = {} | The attributes of entity ExampleCo::Personnel::Employee::\"Rick\" are the record { \"firstName\": \"Rick\", \"jobLevel\" : \"admin\" } | . For this request the PARC components conform to the schema, but the attributes of entity ExampleCo::Personnel::Employee::\"Rick\" do not: The schema prescribes that attributes name and jobLevel must be present, and the latter is mapped to value of type Long, but neither is true of the entity given in the request. If we evaluated the policy on this request the policy’s when-condition expression principal.name == \"superuser\" would fail with a message like ExampleCo::Personnel::Employee::”Rick” does not have the required attribute: name. If we changed the entity in the request so that firstName was instead name as required by the schema, evaluation would fail on principal.jobLevel &gt; 8 with a message like type error: expected long, got string. By default, it is entirely up to the application to make sure that authorization requests are well-formed according to the schema’s expectations. However, a future feature (described in RFC 11) will allow applications to optionally validate that the PAR parts of a PARC request adhere to the expectations given in the schema. Applications can also choose to use schema-based parsing to ensure that JSON data used to describe entities and/or a request’s context C match the prescriptions of the schema. For example, schema-based parsing would catch the issue above by flagging { \"firstName\": \"Rick\", \"jobLevel\" : \"admin\" } as an invalid entity of type Employee (assuming C was created by parsing a JSON representation of the context data). If an application writer is sure that requests will always match the schema’s expectations by construction, they can elect to skip these steps. You can think of a schema as a contract between the application and the policies: If the application provides requests and data that follow the prescriptions in the schema, then evaluating policies validated against that schema will surely avoid several classes of error. (The end of this section discusses in detail what errors are and are not precluded by validation.) . Note that this contract implies that if an application’s schema changes then so has its authorization model, i.e., the actions and/or entities it may submit to the Cedar authorization engine, and their structure. Policies still in effect may need to be revalidated to make sure they are consistent with these changes. ",
    "url": "/validation.html#enforcement-of-validation-rules-expectations",
    
    "relUrl": "/validation.html#enforcement-of-validation-rules-expectations"
  },"112": {
    "doc": "Policy validation",
    "title": "Benefits of validation and schemas",
    "content": "Performing validation before using your policies gives you a significant benefit, called validation soundness: If your policies are deemed valid, they are sure not to exhibit most errors that could arise during request evaluation, for requests that adhere to the expectations defined by the schema. We have formally proved validation soundness as part of the novel verification guided development process we used to build Cedar. In particular, we implemented a version of the validator in the Dafny verification-aware programming language, and used automated reasoning to prove the validation soundness property. Then we performed extensive differential testing to make sure that our Rust implementation of the validator behaves the same as the Dafny version does. Validation soundness ensures the absence of most, but not all errors that could arise during policy evaluation. The only errors that are not precluded are the following: . | Errors due to integer overflow. In Cedar when you add two large Long numbers together the result may be too big to fit in 64 bits. Rather than wrap around (e.g., producing a negative number) as in many languages, Cedar throws an error. Validation does not currently attempt to detect this possibility, but we are developing such detection as a future feature. | Errors due to missing entities. If a policy references an entity that does not exist in the entities used to evaluate the policy, any attempt to access that entity’s attributes will fail. This could happen with an entity literal (e.g., User::\"Rick\".name == \"rick\") or with an entity passed in as a principal or resource (e.g., principal.name == \"rick\", or principal.manager.name == \"Vijay\" where principal.manager should be an entity). Request validation (RFC 11) and schema-based JSON parsing do not confirm the existence of entities. | Errors due to incorrect Extension values (in non-strict mode). IP addresses and decimals are constructed by calling a function, either ip() or decimal(), with a string. For policies that pass non-literal strings to these functions, there is a risk that the string is not well-formed, and thus evaluating it will produce an error. For example, if we had a policy with the expression ip(principal.IPAddr) and principal.IPAddr happened to be the string \"XYZ\" then evaluating the policy would fail with an error. However, by default the validator runs in a strict mode that forbids passing non-literal strings to extension function constructors; in this mode, the expression above will fail to validate with the error extension constructors may not be called with non-literal expressions. An expression like ip(\"XYZ\") in a policy will fail to validate (regardless of mode). | . All other errors (as enumerated earlier) will never happen. We close by noting that defining a schema is useful for purposes other than validation. | Because a schema describes the properties of an authorization system, they can serve as an input to other tooling, such as documentation generators. | Schemas can be used to generate policy editor interfaces in situations where end-users manage fine-grained rules through point-and-click selections. | Analytics engines that query a body of policies to answer questions might rely on the existence of a schema to produce the most accurate reports. | Sample solutions for authorization scenarios are typically expressed using a schema file. For example, you can answer the question “How can I model situation XYZ?” with a schema that describes the modeling approach. | . Although you can get started in Cedar without using a schema, we encourage you to define and use one, especially as your project moves beyond initial prototyping and toward a production release. ",
    "url": "/validation.html#benefits-of-validation-and-schemas",
    
    "relUrl": "/validation.html#benefits-of-validation-and-schemas"
  },"113": {
    "doc": "Policy validation",
    "title": "Policy validation",
    "content": " ",
    "url": "/validation.html",
    
    "relUrl": "/validation.html"
  },"114": {
    "doc": "What is Cedar?",
    "title": "What is the Cedar policy language?",
    "content": "This guide is a reference for Version 2.3 of the Cedar policy language. Cedar is a language for writing authorization policies and making authorization decisions based on those policies. When you create an application, you need to ensure that only authorized users can access the application, and can do only what each user is authorized to do. Using Cedar, you can decouple your business logic from the authorization logic. In your application’s code, you preface requests made to your operations with a call to Cedar’s authorization engine, asking “Is this request authorized?”. Then, the application can either perform the requested operation if the decision is “allow”, or return an error message if the decision is “deny”. In addition to supporting the authorization requirements for your own custom applications directly, Cedar is the policy language for several authorization services. These services take the separation of business logic and authorization logic one step further: The services host the Cedar policies, and provide APIs for managing those policies and carrying out authorization decisions on behalf of all of your applications. They handle the heavy lifting so your applications don’t have to. Topics on this page . | Overview | Are you a first-time Cedar user? | Features of Cedar . | Policy-based | Supports attributes on entities and sessions | Expressive | Policies are separate from your application’s code | High performing | Human-readable | . | Services that use Cedar | . ",
    "url": "/what-is-cedar.html#what-is-the-cedar-policy-language",
    
    "relUrl": "/what-is-cedar.html#what-is-the-cedar-policy-language"
  },"115": {
    "doc": "What is Cedar?",
    "title": "Overview",
    "content": "To make secure authorization decisions that you can trust, Cedar uses the following elements: . | Authorization policies – Policies describe who (the principal) is allowed to perform which actions, on which resources, and in what context. For example, a policy might state that only members of the janeFriends group (the principals) can view and comment (the actions) on the photos in the janeVacation album (the resources). Another example policy might state that the employees of a company (the principals) can read (the actions) only their own Human Resources records (the resources), and only during regular business hours (the context). A policy for a medical application might state that only a doctor currently associated with a patient can create a referral to a different doctor. For more information, see Policy in Cedar terms and concepts. | Entities – Entities are application data that Cedar needs to see to make authorization decisions. For example, a request might ask if User::\"jane\" is allowed to perform Action::\"viewPhoto\" on the Photo::\"GoldenGateBridge.jpg\". Here, User, Action, and Photo are all different types of entity, and the quoted strings are specific identifiers. To decide this request, Cedar’s authorization engine must have access to these specific entities and any related entities, such as any groups that Jane is a member of, and any albums that contain the specified picture. The engine must also have access to all of those entities’ attributes. This collection of information about the relevant entities must be provided to the authorization engine as part of the request, along with the policies to evaluate. | Schema – A schema defines the types of entities recognized by the application, and which are also the principals, resources, and actions referenced in policies. For example, in a media sharing application, the schema might define a User and the concept of nested “groups” that a User can belong to. It might also define a “photo” and the concept of nested “albums” that can contain photos. Each principal and resource can also have attributes defined, such as Name, Address, Age, and any others relevant to the scenario. Finally, the schema also defines the actions that the application supports, such as viewing photos or reading HR records. Cedar doesn’t use the schema when evaluating an authorization request. Instead, it uses the schema to validate the policies only when you create or update them. This approach helps ensure that your authorization decisions are based on correctly designed policies that reflect your intentions for the application. For more information, see Schema in Cedar terms and concepts. | Context – The context is a part of a request that consists of transient data. The context can include session-specific elements, such as the time the request was made, the IP address the request was sent from, and whether the user authenticated using multi-factor authentication (MFA) when signing in. Policies can reference these elements to support requirements such as only allowing access during business hours, only allowing access from a recognized address in the company network’s IP address range, or allowing sensitive administrator operations only when the user authenticated with MFA. | . Cedar evaluates each request against the provided policies and entities to make an allow or deny decision. The policies are completely separate from your application’s code. This design ensures that your security team can update permissions for your application without having to touch the application’s code. A change to a policy can result in an immediate change in the logic used to authorize requests. ",
    "url": "/what-is-cedar.html#overview",
    
    "relUrl": "/what-is-cedar.html#overview"
  },"116": {
    "doc": "What is Cedar?",
    "title": "Are you a first-time Cedar user?",
    "content": "If you are a first-time user of Cedar, we recommend that you begin by reading the following sections: . | Review and become familiar with the terms and concept associated with Cedar. | Review and become familiar with the scenario upon which the examples in this guide are based. | Learn basic Cedar policy syntax and its construction. | Learn how to define a Cedar schema that can validate your policies and ensure you’re getting the evaluation results you intend. | . ",
    "url": "/what-is-cedar.html#are-you-a-first-time-cedar-user",
    
    "relUrl": "/what-is-cedar.html#are-you-a-first-time-cedar-user"
  },"117": {
    "doc": "What is Cedar?",
    "title": "Features of Cedar",
    "content": "Cedar provides several important features. Policy-based . Cedar policies are written as rules that specify the conditions under which access to resources is to be allowed or denied. You define a policy as a set of statements that include conditions that evaluate the attributes of the requester, the resource being accessed, and the context of the request. Supports attributes on entities and sessions . Cedar policies can use attributes, which are key-value pairs that represent various aspects of the principal, the resource, and the caller’s current session which defines the context of the request. Attributes can include information such as user roles, resource types, time of day, location, and any other relevant contextual information. Expressive . Cedar is a simple yet expressive language that is designed to support common authorization use cases, such as role-based access control (RBAC) and attribute-based access control (ABAC). The language supports logical operators such as AND, OR, and NOT on Boolean values, in addition to common operators on other types, such as comparison operators on integers. This broad set of operators helps provide fine-grained control over access decisions. Policies are separate from your application’s code . The Cedar evaluation engine evaluates policies dynamically. This design supports making changes in access control requirements that take effect immediately, and without requiring system-wide updates or downtime. This approach helps you to quickly and easily adapt to changing business rules or environmental conditions. High performing . Cedar is fast and scalable. The policy structure allows your policies to be indexed for quick retrieval. The design also supports fast, scalable, real-time evaluation with bounded latency. Human-readable . Cedar policies are designed to be easy to read and understand, making them accessible to both technical and non-technical stakeholders involved in defining access control policies. This helps facilitate collaboration and communication among different stakeholders in a distributed system. ",
    "url": "/what-is-cedar.html#features-of-cedar",
    
    "relUrl": "/what-is-cedar.html#features-of-cedar"
  },"118": {
    "doc": "What is Cedar?",
    "title": "Services that use Cedar",
    "content": "For a list of some of the services that use Cedar as their policy language, see Cedar Integrations . ",
    "url": "/what-is-cedar.html#services-that-use-cedar",
    
    "relUrl": "/what-is-cedar.html#services-that-use-cedar"
  },"119": {
    "doc": "What is Cedar?",
    "title": "What is Cedar?",
    "content": " ",
    "url": "/what-is-cedar.html",
    
    "relUrl": "/what-is-cedar.html"
  }
}
