<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Policy validation | Cedar Policy Language Version 2.3 Reference Guide</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="Policy validation" /> <meta property="og:locale" content="en_US" /> <link rel="canonical" href="http://localhost:4000/validation.html" /> <meta property="og:url" content="http://localhost:4000/validation.html" /> <meta property="og:site_name" content="Cedar Policy Language Version 2.3 Reference Guide" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Policy validation" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","headline":"Policy validation","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/images/Cedar1-green.png"}},"url":"http://localhost:4000/validation.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> <div class="site-logo" role="img" aria-label="Cedar Policy Language Version 2.3 Reference Guide"></div> </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Table of contents</a></li><li class="nav-list-item"><a href="/what-is-cedar.html" class="nav-list-link">What is Cedar?</a></li><li class="nav-list-item"><a href="/terminology.html" class="nav-list-link">Terms & concepts</a></li><li class="nav-list-item"><a href="/scenario.html" class="nav-list-link">Example scenario</a></li><li class="nav-list-item"><a href="/authorization.html" class="nav-list-link">Authorization</a></li><li class="nav-list-item active"><a href="/validation.html" class="nav-list-link active">Policy validation</a></li><li class="nav-list-item"><a href="/schema.html" class="nav-list-link">Schema format</a></li><li class="nav-list-item"><a href="/templates.html" class="nav-list-link">Policy templates</a></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Policy syntax category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/syntax.html" class="nav-list-link">Policy syntax</a><ul class="nav-list"><li class="nav-list-item "><a href="/syntax-policy.html" class="nav-list-link">Basic syntax</a></li><li class="nav-list-item "><a href="/syntax-entity.html" class="nav-list-link">Entity</a></li><li class="nav-list-item "><a href="/syntax-datatypes.html" class="nav-list-link">Data types</a></li><li class="nav-list-item "><a href="/syntax-operators.html" class="nav-list-link">Operators</a></li><li class="nav-list-item "><a href="/syntax-grammar.html" class="nav-list-link">Grammar</a></li></ul></li><li class="nav-list-item"><a href="/security.html" class="nav-list-link">Security</a></li><li class="nav-list-item"><a href="/doc-history.html" class="nav-list-link">Document history</a></li><li class="nav-list-item"><a href="/about/" class="nav-list-link">About</a></li></ul> </nav> <p>We welcome your feedback about these docs!<br> <a href="mailto:cedar-docs@amazon.com?subject=Feedback&body=My%20name%20%28optional%29:%0D%0A%0D%0AMy%20email%20%28optional%29:%0D%0A%0D%0AWhat%20I%20was%20trying%20to%20do:%0D%0A%0D%0AWhat%20to%20make%20better:">Send feedback by email</a> or use <a href="https://github.com/cedar-policy/cedar-docs/issues">GitHub Issues</a></p> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Cedar Policy Language Version 2.3 Reference Guide" aria-label="Search Cedar Policy Language Version 2.3 Reference Guide" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 class="no_toc" id="cedar-policy-validation-against-schema"> <a href="#cedar-policy-validation-against-schema" class="anchor-heading" aria-labelledby="cedar-policy-validation-against-schema"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Cedar policy validation against schema<a name="validation"></a> </h1> <p>Cedar policies are code, and as with all code it is possible to make mistakes that mean the code will not behave as expected. For example, the following is a well-formed Cedar policy according to syntax rules, but with a number of typos and type errors.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>permit (
    principal == ExampleCo::Uzer::"12345",   // should be "User", not "Uzer"
    action == ExampleCo::Action::"ReadFile", // should be "readFile", not "ReadFile"
    resource == ExampleCo::User::"67890"     // "readFile" isn't a valid operation on a User
)
when {
    principal.isAcctive           // should be "isActive", not "isAcctive"
      &amp;&amp;
    principal.username &gt; 2        // comparing a string against a number
};
</code></pre></div></div> <p>Cedar can’t know whether this policy is right or wrong by examining it in isolation. For example, Cedar does not know if the policy author meant <code class="language-plaintext highlighter-rouge">Uzer</code> or <code class="language-plaintext highlighter-rouge">User</code> because both are well-formed names. If the policy were subsequently evaluated during an authorization decision, it either would not match at all due to the mistakes in the policy scope (e.g., if there are no entities of type <code class="language-plaintext highlighter-rouge">Uzer</code> then the first comparison would always be false), or if the scope’s errors were corrected the evaluator would return diagnostics about accessing undefined attributes and performing invalid comparisons of strings and integers. Ultimately, the policy will have no impact: policies that always evaluate to <code class="language-plaintext highlighter-rouge">false</code> or exhibit errors during evaluation are ignored.</p> <p>If no policy grants access, Cedar returns a default decision of <code class="language-plaintext highlighter-rouge">DENY</code>. However, it can be frustrating when a policy isn’t behaving as expected. To avoid this frustration, it is better to learn that a policy is invalid when you’re creating it, so mistakes can be fixed before they have an impact on your application’s operation.</p> <p>This capability is provided by Cedar <strong>validation</strong>. To validate a policy, Cedar needs information about the application. It needs to know the correct names of entity types, the attributes they possess, and the allowed parent/child relationships. It also needs to know which actions are allowed, and the expected types of the principal, resource, and context components that are part of requests made with this action. All of this information is provided to Cedar by defining a <a href="/terminology.html#term-schema"><strong>schema</strong></a>.</p> <p>This topic provides a brief overview of schemas and how they work to provide validation. For a full description of the schema format with a sample schema, see <a href="/schema.html">Cedar schema format</a>.</p> <details open=""> <summary class="text-delta"> Topics on this page </summary> <ul id="markdown-toc"> <li><a href="#example-of-schema-based-validation" id="markdown-toc-example-of-schema-based-validation">Example of schema-based validation<a name="schema-intro"></a></a></li> <li><a href="#supported-validation-checks" id="markdown-toc-supported-validation-checks">Supported validation checks<a name="validation-supported-checks"></a></a></li> <li><a href="#enforcement-of-validation-rules-expectations" id="markdown-toc-enforcement-of-validation-rules-expectations">Enforcement of validation rules: Expectations<a name="validation-enforcement"></a></a></li> <li><a href="#benefits-of-validation-and-schemas" id="markdown-toc-benefits-of-validation-and-schemas">Benefits of validation and schemas<a name="validation-benefits-of-schema"></a></a></li> </ul> </details> <h2 id="example-of-schema-based-validation"> <a href="#example-of-schema-based-validation" class="anchor-heading" aria-labelledby="example-of-schema-based-validation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Example of schema-based validation<a name="schema-intro"></a> </h2> <p>The following is an example of a basic Cedar schema.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "ExampleCo::Personnel": {
        "entityTypes": {
            "Employee": {
                "shape": {
                    "type": "Record",
                    "attributes": {
                        "name": { "type": "String" },
                        "jobLevel": { "type": "Long" },
                        "numberOfLaptops": {
                            "type": "Long",
                            "required": false
                        }
                    }
                }
            }
        },
        "actions": {
            "remoteAccess": {
                "appliesTo": {
                    "principalTypes": ["Employee"]
                }
            }
        }
    }
}
</code></pre></div></div> <p>This schema specifies the following:</p> <ul> <li>The entities defined in this schema exist in the namespace <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel</code>. References to those entities <em>within policies</em> require the namespace prefix, e.g., <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Employee</code>. References to those entities <em>within the schema</em>, within the namespace declaration, need no namespace prefix, e.g., we write just <code class="language-plaintext highlighter-rouge">Employee</code> in the <code class="language-plaintext highlighter-rouge">principalTypes</code> part, rather than <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Employee</code>.</li> <li>Every entity of type <code class="language-plaintext highlighter-rouge">Employee</code> in the store has an attribute <code class="language-plaintext highlighter-rouge">name</code> with a value that is a Cedar <code class="language-plaintext highlighter-rouge">String</code>, an attribute <code class="language-plaintext highlighter-rouge">jobLevel</code> with a value that is a Cedar <code class="language-plaintext highlighter-rouge">Long</code>, and an optional attribute <code class="language-plaintext highlighter-rouge">numberOfLaptops</code> that is also a Cedar <code class="language-plaintext highlighter-rouge">Long</code>.</li> <li>Any authorization request from the application that specifies action <code class="language-plaintext highlighter-rouge">Action::"remoteAccess"</code> is expected to specify only principals that are of type <code class="language-plaintext highlighter-rouge">Employee</code> (with no restriction on the type of a request’s resource).</li> </ul> <p>Consider the following policy.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>permit (
    principal,
    action == ExampleCo::Personnel::Action::"remoteAccess",
    resource
)
when {
    principal.numberOfLatpops &lt; 5 &amp;&amp;        // (1)
    principal.name &gt; 3 &amp;&amp;                   // (2)
    principal.jobLevel == "somethingelse"   // (3)
};
</code></pre></div></div> <p>The Cedar validator knows that any request that triggers evaluation of this policy must have action <code class="language-plaintext highlighter-rouge">Action::"remoteAccess"</code>. According to our example schema, such a request must have a principal of type <code class="language-plaintext highlighter-rouge">Employee</code> (the resource can be anything, or unspecified). With this knowledge, validation will report an error or warning on each of the comparisons 1 through 3 in the <code class="language-plaintext highlighter-rouge">when</code> clause for the following reasons:</p> <ol> <li> <p><strong>Validation error</strong> – The policy tries to access an attribute that isn’t defined for <code class="language-plaintext highlighter-rouge">Employee</code> types. In this case, the error is because of a typo (<code class="language-plaintext highlighter-rouge">numberOfLatpops</code> instead of <code class="language-plaintext highlighter-rouge">numberOfLaptops</code>).</p> </li> <li> <p><strong>Validation error</strong> – The left operand of <code class="language-plaintext highlighter-rouge">&gt;</code> is of type <code class="language-plaintext highlighter-rouge">String</code>. However, <code class="language-plaintext highlighter-rouge">&gt;</code> only accepts operands of type <code class="language-plaintext highlighter-rouge">Long</code>, so this policy always raises a runtime error.</p> </li> <li> <p><strong>Validation error</strong> – The left operand of <code class="language-plaintext highlighter-rouge">==</code> is always of type <code class="language-plaintext highlighter-rouge">Long</code> and the right operand is always a <code class="language-plaintext highlighter-rouge">String</code>. Because the <code class="language-plaintext highlighter-rouge">==</code> operator always returns false if its operands have different runtime types, this comparison always returns false. Although this comparison won’t raise a runtime error during evaluation, it probably isn’t what the policy author intended and so is flagged as a validation error.</p> </li> </ol> <h2 id="supported-validation-checks"> <a href="#supported-validation-checks" class="anchor-heading" aria-labelledby="supported-validation-checks"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Supported validation checks<a name="validation-supported-checks"></a> </h2> <p>The validator compares a policy with a schema to look for inconsistencies. From these inconsistencies, the validator detects the following errors:</p> <ul> <li><strong>Unrecognized entity types</strong> – For example, misspelling <code class="language-plaintext highlighter-rouge">File</code> as <code class="language-plaintext highlighter-rouge">Filee</code>.</li> <li><strong>Unrecognized actions</strong> – For example, misspelling <code class="language-plaintext highlighter-rouge">Action::"viewFile"</code> as <code class="language-plaintext highlighter-rouge">Action::"viewFiel"</code>.</li> <li><strong>Action applied to unsupported principal or resource</strong> – For example, saying a <code class="language-plaintext highlighter-rouge">File</code> can <code class="language-plaintext highlighter-rouge">View</code> a <code class="language-plaintext highlighter-rouge">User</code>.</li> <li><strong>Improper use of in or ==</strong> – For example, stating <code class="language-plaintext highlighter-rouge">principal in Folder::"folder-name"</code> when a principal can’t be a <code class="language-plaintext highlighter-rouge">File</code>.</li> <li><strong>Unrecognized attributes</strong> – For example, <code class="language-plaintext highlighter-rouge">principal.jobbLevel</code> has a typo and should be <code class="language-plaintext highlighter-rouge">jobLevel</code>.</li> <li><strong>Unsafe access to optional attributes</strong> – For example, <code class="language-plaintext highlighter-rouge">principal.numberOfLaptops</code> where <code class="language-plaintext highlighter-rouge">numberOfLaptops</code> is an optional attribute declared with <code class="language-plaintext highlighter-rouge">"required": false</code>. Such tests should be guarded by including a <a href="/syntax-operators.html#operator-has"><code class="language-plaintext highlighter-rouge">has</code></a> check as the left side of the shortcut <a href="/syntax-operators.html#operator-and">&amp;&amp;</a> expression. For example, as in <code class="language-plaintext highlighter-rouge">principal has numberOfLaptops &amp;&amp; principal.numberOfLaptops &gt; 1</code>.</li> <li><strong>Type mismatch in operators</strong> – For example, <code class="language-plaintext highlighter-rouge">principal.jobLevel &gt; "14"</code> is an illegal comparison with a <code class="language-plaintext highlighter-rouge">String</code>.</li> <li><strong>Cases that always evaluate to false, and thus never apply</strong> – For example, <code class="language-plaintext highlighter-rouge">when { principal has manager &amp;&amp; principal.manager == User::"Ethel" }</code> always evaluates to <code class="language-plaintext highlighter-rouge">false</code> when the type of <code class="language-plaintext highlighter-rouge">principal</code> will never have the <code class="language-plaintext highlighter-rouge">manager</code> attribute, as made clear in the schema, so the policy can never apply.</li> </ul> <p>The schema can also specify the expected format of the context record for each <code class="language-plaintext highlighter-rouge">Action</code>. Making this specification lets Cedar also flag errors on references to context.</p> <h2 id="enforcement-of-validation-rules-expectations"> <a href="#enforcement-of-validation-rules-expectations" class="anchor-heading" aria-labelledby="enforcement-of-validation-rules-expectations"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Enforcement of validation rules: Expectations<a name="validation-enforcement"></a> </h2> <p>As implied by the discussion above, we expect validation to be performed <em>before</em> a policy is used by the authorization engine to decide authorization requests. Indeed, the Cedar authorization APIs do not perform validation at the same time that a request is evaluated. Rather, validation is an entirely separate API which can be invoked when policies are loaded or created.</p> <p>We expect that <strong>all authorization requests adhere to the rules given in the schema</strong> used to validate the policies. In particular:</p> <ul> <li>For a request with components <em>PARC</em> (principal, action, resource, context), the <em>A</em> component must be an action enumerated in the <code class="language-plaintext highlighter-rouge">actions</code> part of the schema, and the <em>PRC</em> components will have the types given with <em>A</em> in the schema. Our example schema above states that <em>A</em> must always be <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Action::"remoteAccess"</code> (since it’s the only action given in the schema), and for this action <em>P</em> must be an entity of type <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Employee</code>, <em>R</em> can be any entity (or omitted entirely), and <em>C</em> must be the empty record <code class="language-plaintext highlighter-rouge">{}</code> (since no information about the context is given).</li> <li>The entities used when evaluating the request must have the structure given in the <code class="language-plaintext highlighter-rouge">entityTypes</code> part of the schema. Our example schema above states that <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Employee</code> entities have at least two attributes (<code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">jobLevel</code>) and optionally have a third (<code class="language-plaintext highlighter-rouge">numberOfLaptops</code>), each with the types given (<code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Long</code>, and <code class="language-plaintext highlighter-rouge">Long</code>, respectively). Schemas may also specify the expected hierarchical relationships among entities (not shown in the example).</li> </ul> <p>If these expectations are not met then a policy that the validator accepts as valid may fail with an error when evaluated, causing it to be ignored. To see why, consider the following policy, which passes validation when using our example schema.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>permit(principal, action, resource)
when {
    principal.name == "superuser" ||
    principal.jobLevel &gt; 8
};
</code></pre></div></div> <p>This policy states that any principal whose <code class="language-plaintext highlighter-rouge">name</code> is <code class="language-plaintext highlighter-rouge">"superuser"</code> or whose <code class="language-plaintext highlighter-rouge">jobLevel</code> is greater than 8 can perform any action on any resource. According to our example schema, all principals are expected to have type <code class="language-plaintext highlighter-rouge">Employee</code>, which is the only principal type given for the sole action listed.</p> <p>Now suppose we submitted the following authorization request:</p> <ul> <li><em>P</em> = <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Employee::"Rick"</code></li> <li><em>A</em> = <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Action::"remoteAccess"</code></li> <li><em>R</em> = <em>omitted</em></li> <li><em>C</em> = <code class="language-plaintext highlighter-rouge">{}</code></li> <li>The attributes of entity <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Employee::"Rick"</code> are the record <code class="language-plaintext highlighter-rouge">{ "firstName": "Rick", "jobLevel" : "admin" }</code></li> </ul> <p>For this request the <em>PARC</em> components conform to the schema, but the attributes of entity <code class="language-plaintext highlighter-rouge">ExampleCo::Personnel::Employee::"Rick"</code> do not: The schema prescribes that attributes <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">jobLevel</code> must be present, and the latter is mapped to value of type <code class="language-plaintext highlighter-rouge">Long</code>, but neither is true of the entity given in the request. If we evaluated the policy on this request the policy’s <code class="language-plaintext highlighter-rouge">when</code>-condition expression <code class="language-plaintext highlighter-rouge">principal.name == "superuser"</code> would fail with a message like <em>ExampleCo::Personnel::Employee::”Rick” does not have the required attribute: name</em>. If we changed the entity in the request so that <code class="language-plaintext highlighter-rouge">firstName</code> was instead <code class="language-plaintext highlighter-rouge">name</code> as required by the schema, evaluation would fail on <code class="language-plaintext highlighter-rouge">principal.jobLevel &gt; 8</code> with a message like <em>type error: expected long, got string</em>.</p> <p>By default, it is entirely up to the application to make sure that authorization requests are well-formed according to the schema’s expectations. However, a future feature (described in <a href="https://github.com/cedar-policy/rfcs/pull/11">RFC 11</a>) will allow applications to <em>optionally</em> validate that the <em>PAR</em> parts of a <em>PARC</em> request adhere to the expectations given in the schema. Applications can also choose to use schema-based parsing to ensure that JSON data used to describe entities and/or a request’s context <em>C</em> match the prescriptions of the schema. For example, schema-based parsing would catch the issue above by flagging <code class="language-plaintext highlighter-rouge">{ "firstName": "Rick", "jobLevel" : "admin" }</code> as an invalid entity of type <code class="language-plaintext highlighter-rouge">Employee</code> (assuming <em>C</em> was created by parsing a JSON representation of the context data). If an application writer is sure that requests will always match the schema’s expectations by construction, they can elect to skip these steps.</p> <p>You can think of a schema as a contract between the application and the policies: If the application provides requests and data that follow the prescriptions in the schema, then evaluating policies validated against that schema will surely avoid several classes of error. (The <a href="#validation-benefits-of-schema">end of this section</a> discusses in detail what errors are and are not precluded by validation.)</p> <p>Note that this contract implies that if an application’s schema changes then so has its authorization model, i.e., the actions and/or entities it may submit to the Cedar authorization engine, and their structure. Policies still in effect may need to be revalidated to make sure they are consistent with these changes.</p> <h2 id="benefits-of-validation-and-schemas"> <a href="#benefits-of-validation-and-schemas" class="anchor-heading" aria-labelledby="benefits-of-validation-and-schemas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Benefits of validation and schemas<a name="validation-benefits-of-schema"></a> </h2> <p>Performing validation before using your policies gives you a significant benefit, called <em>validation soundness</em>: If your policies are deemed valid, they are sure not to exhibit most errors that could arise during request evaluation, for requests that adhere to the expectations defined by the schema. We have formally <em>proved</em> validation soundness as part of the novel <a href="https://www.amazon.science/blog/how-we-built-cedar-with-automated-reasoning-and-differential-testing">verification guided development</a> process we used to build Cedar. In particular, we implemented a version of the validator in the <a href="https://dafny.org">Dafny verification-aware programming language</a>, and used <a href="https://www.amazon.science/blog/a-gentle-introduction-to-automated-reasoning">automated reasoning</a> to prove the validation soundness property. Then we performed extensive <em>differential testing</em> to make sure that our Rust implementation of the validator behaves the same as the Dafny version does.</p> <p>Validation soundness ensures the absence of most, but not all errors that could arise during policy evaluation. The only errors that are not precluded are the following:</p> <ul> <li><strong>Errors due to integer overflow</strong>. In Cedar when you add two large <code class="language-plaintext highlighter-rouge">Long</code> numbers together the result may be too big to fit in 64 bits. Rather than wrap around (e.g., producing a negative number) as in many languages, Cedar throws an error. Validation does not currently attempt to detect this possibility, but we are developing such detection as a future feature.</li> <li><strong>Errors due to missing entities</strong>. If a policy references an entity that does not exist in the entities used to evaluate the policy, any attempt to access that entity’s attributes will fail. This could happen with an entity literal (e.g., <code class="language-plaintext highlighter-rouge">User::"Rick".name == "rick"</code>) or with an entity passed in as a principal or resource (e.g., <code class="language-plaintext highlighter-rouge">principal.name == "rick"</code>, or <code class="language-plaintext highlighter-rouge">principal.manager.name == "Vijay"</code> where <code class="language-plaintext highlighter-rouge">principal.manager</code> should be an entity). Request validation (<a href="https://github.com/cedar-policy/rfcs/pull/11">RFC 11</a>) and schema-based JSON parsing do not confirm the existence of entities.</li> <li><strong>Errors due to incorrect <a href="/schema.html#schema-entitytypes-shape-extension">Extension</a> values</strong> (in non-strict mode). IP addresses and decimals are constructed by calling a function, either <code class="language-plaintext highlighter-rouge">ip()</code> or <code class="language-plaintext highlighter-rouge">decimal()</code>, with a string. For policies that pass non-literal strings to these functions, there is a risk that the string is not well-formed, and thus evaluating it will produce an error. For example, if we had a policy with the expression <code class="language-plaintext highlighter-rouge">ip(principal.IPAddr)</code> and <code class="language-plaintext highlighter-rouge">principal.IPAddr</code> happened to be the string <code class="language-plaintext highlighter-rouge">"XYZ"</code> then evaluating the policy would fail with an error. However, by default the validator runs in a <em>strict</em> mode that forbids passing non-literal strings to extension function constructors; in this mode, the expression above will fail to validate with the error <em>extension constructors may not be called with non-literal expressions</em>. An expression like <code class="language-plaintext highlighter-rouge">ip("XYZ")</code> in a policy will fail to validate (regardless of mode).</li> </ul> <p>All other errors (as enumerated <a href="#supported-validation-checks">earlier</a>) will never happen.</p> <p>We close by noting that defining a schema is useful for purposes other than validation.</p> <ul> <li>Because a schema describes the properties of an authorization system, they can serve as an input to other tooling, such as documentation generators.</li> <li>Schemas can be used to generate policy editor interfaces in situations where end-users manage fine-grained rules through point-and-click selections.</li> <li>Analytics engines that query a body of policies to answer questions might rely on the existence of a schema to produce the most accurate reports.</li> <li>Sample solutions for authorization scenarios are typically expressed using a schema file. For example, you can answer the question “How can I model situation XYZ?” with a schema that describes the modeling approach.</li> </ul> <p>Although you can get started in Cedar without using a schema, we encourage you to define and use one, especially as your project moves beyond initial prototyping and toward a production release.</p> </main> <hr> <footer> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/cedar-policy/cedar-docs/tree/main/docs/validation.md" id="edit-this-page">We welcome your feedback. You can edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
